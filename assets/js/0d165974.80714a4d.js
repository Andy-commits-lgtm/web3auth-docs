"use strict";(self.webpackChunkweb3auth_docs=self.webpackChunkweb3auth_docs||[]).push([[59414],{24374:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>d,default:()=>y,frontMatter:()=>l,metadata:()=>h,toc:()=>p});var r=n(85893),a=n(11151);function s(e){const t={code:"code",pre:"pre",...(0,a.a)(),...e.components},{Details:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:(0,r.jsx)("code",{children:"src/utils.ts"})}),(0,r.jsx)("p",{children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",metastring:'title="src/utils.ts"',children:'import BN from "bn.js";\nimport { encrypt, getPubKeyECC, Point, randomSelection, ShareStore } from "@tkey-mpc/common-types";\nimport EC from "elliptic";\n\nimport { generatePrivate } from "@toruslabs/eccrypto";\nimport { Client } from "@toruslabs/tss-client";\nimport * as tss from "@toruslabs/tss-lib";\nimport { EthereumSigningProvider } from "@web3auth-mpc/ethereum-provider";\nimport keccak256 from "keccak256";\nimport Web3 from "web3";\nimport type { provider } from "web3-core";\nimport { utils } from "@toruslabs/tss-client";\nconst { getDKLSCoeff, setupSockets } = utils;\n\nconst parties = 4;\nconst clientIndex = parties - 1;\nconst tssImportUrl = `https://sapphire-dev-2-2.authnetwork.dev/tss/v1/clientWasm`;\n\nconst DELIMITERS = {\n  Delimiter1: "\\u001c",\n  Delimiter2: "\\u0015",\n  Delimiter3: "\\u0016",\n  Delimiter4: "\\u0017",\n};\n\nexport function getEcCrypto(): any {\n  // eslint-disable-next-line new-cap\n  return new EC.ec("secp256k1");\n}\nconst ec = getEcCrypto();\n\nexport const generateTSSEndpoints = (tssNodeEndpoints: string[], parties: number, clientIndex: number) => {\n  const endpoints: string[] = [];\n  const tssWSEndpoints: string[] = [];\n  const partyIndexes: number[] = [];\n  for (let i = 0; i < parties; i++) {\n    partyIndexes.push(i);\n    if (i === clientIndex) {\n      endpoints.push(null as any);\n      tssWSEndpoints.push(null as any);\n    } else {\n      endpoints.push(tssNodeEndpoints[i]);\n      tssWSEndpoints.push(new URL(tssNodeEndpoints[i]).origin);\n    }\n  }\n  return { endpoints, tssWSEndpoints, partyIndexes };\n};\n\nexport const setupWeb3 = async (chainConfig: any, loginReponse: any, signingParams: any) => {\n  try {\n    const ethereumSigningProvider = new EthereumSigningProvider({\n      config: {\n        chainConfig,\n      },\n    });\n\n    const { tssNonce, tssShare2, tssShare2Index, compressedTSSPubKey, signatures, nodeDetails } = signingParams;\n\n    const { verifier, verifierId } = loginReponse.userInfo;\n\n    const vid = `${verifier}${DELIMITERS.Delimiter1}${verifierId}`;\n    const sessionId = `${vid}${DELIMITERS.Delimiter2}default${DELIMITERS.Delimiter3}${tssNonce}${DELIMITERS.Delimiter4}`;\n\n    /*\n    pass user\'s private key here.\n    after calling setupProvider, we can use\n    */\n    const sign = async (msgHash: Buffer) => {\n      const randomSessionNonce = keccak256(generatePrivate().toString("hex") + Date.now());\n\n      // session is needed for authentication to the web3auth infrastructure holding the factor 1\n      const currentSession = `${sessionId}${randomSessionNonce.toString("hex")}`;\n\n      // 1. setup\n      // generate endpoints for servers\n      const { endpoints, tssWSEndpoints, partyIndexes } = generateTSSEndpoints(nodeDetails.serverEndpoints, parties, clientIndex);\n\n      // setup mock shares, sockets and tss wasm files.\n      const [sockets] = await Promise.all([setupSockets(tssWSEndpoints as string[], randomSessionNonce.toString("hex")), tss.default(tssImportUrl)]);\n\n      const participatingServerDKGIndexes = [1, 2, 3];\n      const dklsCoeff = getDKLSCoeff(true, participatingServerDKGIndexes, tssShare2Index);\n      const denormalisedShare = dklsCoeff.mul(tssShare2).umod(ec.curve.n);\n      const share = Buffer.from(denormalisedShare.toString(16, 64), "hex").toString("base64");\n\n      if (!currentSession) {\n        throw new Error(`sessionAuth does not exist ${currentSession}`);\n      }\n      if (!signatures) {\n        throw new Error(`Signature does not exist ${signatures}`);\n      }\n\n      const client = new Client(\n        currentSession,\n        clientIndex,\n        partyIndexes,\n        endpoints,\n        sockets,\n        share,\n        compressedTSSPubKey.toString("base64"),\n        true,\n        tssImportUrl,\n      );\n      const serverCoeffs: any = {};\n      for (let i = 0; i < participatingServerDKGIndexes.length; i++) {\n        const serverIndex = participatingServerDKGIndexes[i];\n        serverCoeffs[serverIndex] = getDKLSCoeff(false, participatingServerDKGIndexes, tssShare2Index, serverIndex).toString("hex");\n      }\n      client.precompute(tss, { signatures, server_coeffs: serverCoeffs });\n      await client.ready();\n      const { r, s, recoveryParam } = await client.sign(tss as any, Buffer.from(msgHash).toString("base64"), true, "", "keccak256", {\n        signatures,\n      });\n      await client.cleanup(tss, { signatures, server_coeffs: serverCoeffs });\n      return { v: recoveryParam, r: Buffer.from(r.toString("hex"), "hex"), s: Buffer.from(s.toString("hex"), "hex") };\n    };\n\n    if (!compressedTSSPubKey) {\n      throw new Error(`compressedTSSPubKey does not exist ${compressedTSSPubKey}`);\n    }\n\n    const getPublic: () => Promise<Buffer> = async () => {\n      return compressedTSSPubKey;\n    };\n\n    await ethereumSigningProvider.setupProvider({ sign, getPublic });\n    console.log(ethereumSigningProvider.provider);\n    const web3 = new Web3(ethereumSigningProvider.provider as provider);\n    return web3;\n  } catch (e) {\n    console.error(e);\n    return null;\n  }\n};\n\nexport type FactorKeyCloudMetadata = {\n  deviceShare: ShareStore;\n  tssShare: BN;\n  tssIndex: number;\n};\n\nconst fetchDeviceShareFromTkey = async (tKey: any) => {\n  if (!tKey) {\n    console.error("tKey not initialized yet");\n    return;\n  }\n  try {\n    const polyId = tKey.metadata.getLatestPublicPolynomial().getPolynomialID();\n    const shares = tKey.shares[polyId];\n    let deviceShare: ShareStore | null = null;\n\n    for (const shareIndex in shares) {\n      if (shareIndex !== "1") {\n        deviceShare = shares[shareIndex];\n      }\n    }\n    return deviceShare;\n  } catch (err: any) {\n    console.error({ err });\n    throw new Error(err);\n  }\n};\n\nexport const addFactorKeyMetadata = async (tKey: any, factorKey: BN, tssShare: BN, tssIndex: number, factorKeyDescription: string) => {\n  if (!tKey) {\n    console.error("tKey not initialized yet");\n    return;\n  }\n  const { requiredShares } = tKey.getKeyDetails();\n  if (requiredShares > 0) {\n    console.error("not enough shares for metadata key");\n  }\n\n  const metadataDeviceShare = await fetchDeviceShareFromTkey(tKey);\n\n  const factorIndex = getPubKeyECC(factorKey).toString("hex");\n  const metadataToSet: FactorKeyCloudMetadata = {\n    deviceShare: metadataDeviceShare as ShareStore,\n    tssShare,\n    tssIndex,\n  };\n\n  // Set metadata for factor key backup\n  await tKey.addLocalMetadataTransitions({\n    input: [{ message: JSON.stringify(metadataToSet) }],\n    privKey: [factorKey],\n  });\n\n  // also set a description on tkey\n  const params = {\n    module: factorKeyDescription,\n    dateAdded: Date.now(),\n    tssShareIndex: tssIndex,\n  };\n  await tKey.addShareDescription(factorIndex, JSON.stringify(params), true);\n};\n\nexport const copyExistingTSSShareForNewFactor = async (tKey: any, newFactorPub: Point, factorKeyForExistingTSSShare: BN) => {\n  if (!tKey) {\n    throw new Error("tkey does not exist, cannot copy factor pub");\n  }\n  if (!tKey.metadata.factorPubs || !Array.isArray(tKey.metadata.factorPubs[tKey.tssTag])) {\n    throw new Error("factorPubs does not exist, failed in copy factor pub");\n  }\n  if (!tKey.metadata.factorEncs || typeof tKey.metadata.factorEncs[tKey.tssTag] !== "object") {\n    throw new Error("factorEncs does not exist, failed in copy factor pub");\n  }\n\n  const existingFactorPubs = tKey.metadata.factorPubs[tKey.tssTag].slice();\n  const updatedFactorPubs = existingFactorPubs.concat([newFactorPub]);\n  const { tssShare, tssIndex } = await tKey.getTSSShare(factorKeyForExistingTSSShare);\n\n  const factorEncs = JSON.parse(JSON.stringify(tKey.metadata.factorEncs[tKey.tssTag]));\n  const factorPubID = newFactorPub.x.toString(16, 64);\n  factorEncs[factorPubID] = {\n    tssIndex,\n    type: "direct",\n    userEnc: await encrypt(\n      Buffer.concat([\n        Buffer.from("04", "hex"),\n        Buffer.from(newFactorPub.x.toString(16, 64), "hex"),\n        Buffer.from(newFactorPub.y.toString(16, 64), "hex"),\n      ]),\n      Buffer.from(tssShare.toString(16, 64), "hex"),\n    ),\n    serverEncs: [],\n  };\n  tKey.metadata.addTSSData({\n    tssTag: tKey.tssTag,\n    factorPubs: updatedFactorPubs,\n    factorEncs,\n  });\n};\n\nexport const addNewTSSShareAndFactor = async (\n  tKey: any,\n  newFactorPub: Point,\n  newFactorTSSIndex: number,\n  factorKeyForExistingTSSShare: BN,\n  signatures: any,\n) => {\n  try {\n    if (!tKey) {\n      throw new Error("tkey does not exist, cannot add factor pub");\n    }\n    if (!(newFactorTSSIndex === 2 || newFactorTSSIndex === 3)) {\n      throw new Error("tssIndex must be 2 or 3");\n    }\n    if (!tKey.metadata.factorPubs || !Array.isArray(tKey.metadata.factorPubs[tKey.tssTag])) {\n      throw new Error("factorPubs does not exist");\n    }\n\n    const existingFactorPubs = tKey.metadata.factorPubs[tKey.tssTag].slice();\n    const updatedFactorPubs = existingFactorPubs.concat([newFactorPub]);\n    const existingTSSIndexes = existingFactorPubs.map((fb: any) => tKey.getFactorEncs(fb).tssIndex);\n    const updatedTSSIndexes = existingTSSIndexes.concat([newFactorTSSIndex]);\n    const { tssShare, tssIndex } = await tKey.getTSSShare(factorKeyForExistingTSSShare);\n\n    tKey.metadata.addTSSData({\n      tssTag: tKey.tssTag,\n      factorPubs: updatedFactorPubs,\n    });\n\n    const rssNodeDetails = await tKey._getRssNodeDetails();\n    const { serverEndpoints, serverPubKeys, serverThreshold } = rssNodeDetails;\n    const randomSelectedServers = randomSelection(\n      new Array(rssNodeDetails.serverEndpoints.length).fill(null).map((_, i) => i + 1),\n      Math.ceil(rssNodeDetails.serverEndpoints.length / 2),\n    );\n\n    const verifierNameVerifierId = tKey.serviceProvider.getVerifierNameVerifierId();\n    await tKey._refreshTSSShares(true, tssShare, tssIndex, updatedFactorPubs, updatedTSSIndexes, verifierNameVerifierId, {\n      selectedServers: randomSelectedServers,\n      serverEndpoints,\n      serverPubKeys,\n      serverThreshold,\n      authSignatures: signatures,\n    });\n  } catch (err) {\n    console.error(err);\n    throw err;\n  }\n};\n'})})})]})}function o(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(s,{...e})}):s(e)}var i=n(30831),c=n(32165);const l={title:"Using Web3Auth tKey MPC SDK",image:"content-hub/guides/banners/tkey-mpc.png",description:"Learn how to use the Web3Auth tKey JS MPC SDK in your React Application",type:"guide",tags:["web","corekit","tkey","mpc","google","whitelabel","react","ethereum"],date:"March 15, 2023",author:"Web3Auth Team",order:17,communityPortalTopicId:57},d=void 0,h={type:"mdx",permalink:"/docs/content-hub/guides/tkey-js-mpc",source:"@site/src/pages/content-hub/guides/tkey-js-mpc.mdx",title:"Using Web3Auth tKey MPC SDK",description:"Learn how to use the Web3Auth tKey JS MPC SDK in your React Application",frontMatter:{title:"Using Web3Auth tKey MPC SDK",image:"content-hub/guides/banners/tkey-mpc.png",description:"Learn how to use the Web3Auth tKey JS MPC SDK in your React Application",type:"guide",tags:["web","corekit","tkey","mpc","google","whitelabel","react","ethereum"],date:"March 15, 2023",author:"Web3Auth Team",order:17,communityPortalTopicId:57},unlisted:!1},u={},p=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Understanding the Web3Auth tKey JS MPC SDK",id:"understanding-the-web3auth-tkey-js-mpc-sdk",level:2},{value:"Factors",id:"factors",level:3},{value:"Social Login Factor",id:"social-login-factor",level:5},{value:"Device Factor",id:"device-factor",level:5},{value:"Backup Factor",id:"backup-factor",level:5},{value:"Threshold",id:"threshold",level:3},{value:"Components of a Factor",id:"components-of-a-factor",level:3},{value:"TSS Shares",id:"tss-shares",level:4},{value:"Metadata Key &amp; Shares",id:"metadata-key--shares",level:4},{value:"Factor Keys",id:"factor-keys",level:4},{value:"Setup",id:"setup",level:2},{value:"Setup your Google App",id:"setup-your-google-app",level:3},{value:"Setup your Web3Auth Dashboard",id:"setup-your-web3auth-dashboard",level:3},{value:"Setting up your React Project",id:"setting-up-your-react-project",level:3},{value:"Setting up the service worker",id:"setting-up-the-service-worker",level:3},{value:"Installation",id:"installation",level:2},{value:"Understanding the Dependencies",id:"understanding-the-dependencies",level:3},{value:"<code>@tkey-mpc/*</code>",id:"tkey-mpc",level:6},{value:"<code>@toruslabs/*</code>",id:"toruslabs",level:6},{value:"<code>bn.js</code>, <code>eccrypto</code>, <code>jsrsasign</code>, <code>keccak256</code>",id:"bnjs-eccrypto-jsrsasign-keccak256",level:6},{value:"<code>@web3auth-mpc/ethereum-provider</code>, <code>web3</code>, <code>@ethereumjs/*</code>",id:"web3auth-mpcethereum-provider-web3-ethereumjs",level:6},{value:"Initialization",id:"initialization",level:2},{value:"Adding the MPC utils file",id:"adding-the-mpc-utils-file",level:3},{value:"Triggering Login using Service Provider",id:"triggering-login-using-service-provider",level:2},{value:"Initialize tKey",id:"initialize-tkey",level:2},{value:"Check if user is new or existing",id:"check-if-user-is-new-or-existing",level:3},{value:"Store tKey device factor in local storage",id:"store-tkey-device-factor-in-local-storage",level:3},{value:"Implementing the main <code>initializeNewKey</code> function",id:"implementing-the-main-initializenewkey-function",level:3},{value:"Setup Web3 Provider",id:"setup-web3-provider",level:4},{value:"Copy the Local TSS Share into a Manual Backup Factor Key",id:"copy-the-local-tss-share-into-a-manual-backup-factor-key",level:2},{value:"Create new TSS Share into a Manual Backup Factor Key",id:"create-new-tss-share-into-a-manual-backup-factor-key",level:2},{value:"Get Key Details",id:"get-key-details",level:2},{value:"Interacting with Blockchain",id:"interacting-with-blockchain",level:2},{value:"Example code",id:"example-code",level:2},{value:"Questions?",id:"questions",level:2}];function g(e){const t={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",h5:"h5",h6:"h6",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.Z,{title:"Using Web3Auth tKey MPC SDK",description:"Learn how to use Web3Auth tKey MPC SDK in your React Application.",image:"https://web3auth.io/docs/content-hub/guides/banners/tkey-mpc.png",slug:"/content-hub/guides/tkey-js-mpc"}),"\n",(0,r.jsx)(t.p,{children:"This guide will help you make a react application using Web3Auth tKey MPC SDK, covering the basic functionality on how to use it."}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Live Demo:"})," ",(0,r.jsx)(t.a,{href:"https://w3a.link/tkey-mpc-example",children:"https://w3a.link/tkey-mpc-example"})]}),"\n",(0,r.jsxs)(t.admonition,{type:"note",children:[(0,r.jsx)(t.p,{children:"This is an advanced guide, meant for enterprise developers and contains multiple moving parts that might be difficult to understand. Please contact\nour team if you're looking to integrate this SDK, and we'll be happy to help you out."}),(0,r.jsxs)(t.p,{children:["For general integrations, ",(0,r.jsx)(t.a,{href:"/sdk/core-kit/mpc-core-kit",children:"MPC Core Kit"})," is the best alternative to be used."]})]}),"\n",(0,r.jsx)(t.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"A basic knowledge of JavaScript and React."}),"\n",(0,r.jsx)(t.li,{children:"Ideal to have a knowledge about service workers in React."}),"\n",(0,r.jsxs)(t.li,{children:["A ",(0,r.jsx)(t.a,{href:"https://console.developers.google.com/",children:"Google Developer"})," account to be used as Login provider for Web3Auth Custom Authentication."]}),"\n",(0,r.jsxs)(t.li,{children:["Create a Web3Auth account on the ",(0,r.jsx)(t.a,{href:"https://dashboard.web3auth.io/",children:"Web3Auth Dashboard"})]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"understanding-the-web3auth-tkey-js-mpc-sdk",children:"Understanding the Web3Auth tKey JS MPC SDK"}),"\n",(0,r.jsxs)(t.p,{children:["With the Web3Auth infrastructure, your key is divided into multiple parts and stored across your devices and our Auth Network. This ensures that your\nkey is always available and never stored in a single place. While in the traditional Web3Auth SDK, your key was dynamically reconstructed in the\nfrontend using threshold signatures, with the new Web3Auth MPC (Multi Party Computation) architecture, it is ",(0,r.jsx)(t.strong,{children:"never reconstructed"}),". Instead, these\npartial keys are stored across different locations, and your device is used to make partial signatures for your message/ transaction. These are\nfinally returned to the frontend where using TSS (Threshold Signature Scheme), these signatures are combined to make a final signature. You can use\nthis finally signed message/transaction to make a transaction on the blockchain."]}),"\n",(0,r.jsx)(t.p,{children:"The Threshold Signature Scheme (TSS) is a cryptographic primitive for distributed key generation and signing. The use of TSS in Web3Auth's Auth\nnetwork is a new paradigm that can provide numerous benefits, especially in terms of security."}),"\n",(0,r.jsx)("img",{style:{display:"block",margin:"20px auto"},src:c.Z,alt:"Web3Auth Wallet Management"}),"\n",(0,r.jsx)(t.p,{children:"As you can notice in this diagram above, the final output, i.e., the User's TSS Account, is generated in multiple stages within the infrastructure.\nSince this is a TSS- MPC based infrastructure, you don't get back a private key, but signatures that can be used to make transactions on the\nblockchain. Let's understand each of these stages in detail."}),"\n",(0,r.jsx)(t.h3,{id:"factors",children:"Factors"}),"\n",(0,r.jsx)(t.h5,{id:"social-login-factor",children:"Social Login Factor"}),"\n",(0,r.jsx)(t.p,{children:"This is the primary way for a user to access their account. This step involves authentication using a user's preferred social login provider. The\nidToken received from the social login provider here is passed to the Web3Auth Auth Network to generate the TSS Shares in the Nodes. By default, these\nnodes have a threshold of 3/5 that can be customized according to requirements. When a user logs in, the Auth Network generates signatures\ncorresponding to the TSS Shares in the nodes and returns them to the user's end. These signatures are then used alongside other shares to generate the\nfinal TSS Account signatures."}),"\n",(0,r.jsx)(t.h5,{id:"device-factor",children:"Device Factor"}),"\n",(0,r.jsx)(t.p,{children:"This is the second factor used to access the user's account. This step involves the generation of a TSS Share on the user's device and using that to\ngenerate a final signature for the TSS Account alongside the social login factor. This ensures the user logs in using their trusted device and\nmaintains a proper non-custodial setup."}),"\n",(0,r.jsx)(t.h5,{id:"backup-factor",children:"Backup Factor"}),"\n",(0,r.jsx)(t.p,{children:"A user has a choice to generate as many backup factors as needed to access their account. This step involves the generation of a TSS Share on the\nuser's end and storing them in whichever location they prefer. This share can be used similarly to the device share to generate a final signature for\nthe TSS Account alongside the social login and/or device factors."}),"\n",(0,r.jsx)(t.h3,{id:"threshold",children:"Threshold"}),"\n",(0,r.jsx)(t.p,{children:"The threshold is the minimum number of shares required to generate a final signature for the TSS Account. This threshold, by default, is set to 3/5 on\nthe Auth Network and 2/3 for the user's device front. This ensures high availability and ease of access on both ends alongside optimum security. Both\nthese thresholds can be customized according to the requirements."}),"\n",(0,r.jsx)(t.h3,{id:"components-of-a-factor",children:"Components of a Factor"}),"\n",(0,r.jsx)(t.h4,{id:"tss-shares",children:"TSS Shares"}),"\n",(0,r.jsxs)(t.p,{children:["The TSS Shares are the main component needed for the generation of the final working signature of the user. These shares are generated using\ndistributed key generation and are stored in the Auth Network and the user's device. Since these shares are generated using MPC, they are ",(0,r.jsx)(t.strong,{children:"never\nreconstructed"})," and always stay decentralized and secure."]}),"\n",(0,r.jsx)(t.h4,{id:"metadata-key--shares",children:"Metadata Key & Shares"}),"\n",(0,r.jsx)(t.p,{children:"The Metadata Key closely mimics the storage of the TSS Key and Shares. The only difference is that the metadata key is always reconstructed and used\nfor its encryption/decryption capabilities. It utilizes basic Shamir's Secret Sharing and is initially generated on a users' frontend. The metadata\nkey ensures that the infrastructure is backward compatible with the existing Web3Auth architecture, which utilizes SSS (Shamir's Secret Sharing) as\nthe main key reconstruction scheme."}),"\n",(0,r.jsx)(t.h4,{id:"factor-keys",children:"Factor Keys"}),"\n",(0,r.jsxs)(t.p,{children:["To enable refresh, deletion, and rotational capabilities on the ",(0,r.jsx)(t.code,{children:"tssKey"}),", we also introduce ",(0,r.jsx)(t.strong,{children:"factorKeys"}),". Factor Keys are randomly generated keys\nunique to each factor-generated user's device and backups, like users' phones, chrome extension, on their cloud, assisting third parties, etc."]}),"\n",(0,r.jsx)(t.p,{children:"As shares to the TSS Key and/or Metadata Key may rotate, Factor Keys allow a consistent secret to being saved in these different locations."}),"\n",(0,r.jsx)(t.admonition,{type:"note",children:(0,r.jsxs)(t.p,{children:["For this guide, we will be talking through the Web3Auth tKey JS MPC SDK and showing you a basic example of using it with ",(0,r.jsx)(t.code,{children:"@tkey-mpc/default"})," package."]})}),"\n",(0,r.jsx)(t.h2,{id:"setup",children:"Setup"}),"\n",(0,r.jsx)(t.h3,{id:"setup-your-google-app",children:"Setup your Google App"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["Follow Google\u2019s instructions to ",(0,r.jsx)(t.a,{href:"https://support.google.com/cloud/answer/6158849?hl=en",children:"set up an OAuth 2.0 app."})]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:['Add your application\'s redirect URI into the "Authorized redirect URIs" field. This is the URL that Google will redirect to after authentication.\n',(0,r.jsx)(t.code,{children:"http://localhost:3000/serviceworker/redirect"})]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"Google OAuth2.0 App Dashboard",src:n(37392).Z+"",width:"3104",height:"1974"})}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["Obtain the OAuth ",(0,r.jsx)(t.code,{children:"Client ID"})," from your ",(0,r.jsx)(t.a,{href:"https://console.developers.google.com/",children:"App on the Google Developer dashboard"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"setup-your-web3auth-dashboard",children:"Setup your Web3Auth Dashboard"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["Create a ",(0,r.jsx)(t.strong,{children:"Verifier"})," from the ",(0,r.jsx)(t.strong,{children:"Custom Auth"})," Section of the ",(0,r.jsx)(t.a,{href:"https://dashboard.web3auth.io/",children:"Web3Auth Developer Dashboard"})," with following\nconfiguration:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Choose a name of your choice for the verifier identifier. ",(0,r.jsx)(t.code,{children:"eg. google-tkey-w3a"})]}),"\n",(0,r.jsxs)(t.li,{children:["Select environment: Please note the verifier will be deployed on ",(0,r.jsx)(t.code,{children:"sapphire_mainnet"})," or ",(0,r.jsx)(t.code,{children:"sapphire_devnet"})," environment."]}),"\n",(0,r.jsxs)(t.li,{children:["Select ",(0,r.jsx)(t.code,{children:"Google"})," from the ",(0,r.jsx)(t.strong,{children:"Login Provider"}),". ",(0,r.jsx)(t.img,{alt:"Google - Login Providers list on Web3Auth Dashboard",src:n(59611).Z+"",width:"3276",height:"2784"})]}),"\n",(0,r.jsxs)(t.li,{children:["Paste the ",(0,r.jsx)(t.strong,{children:"Client ID"})," from the Google App(above) to the ",(0,r.jsx)(t.code,{children:"Client ID"})," field.\n",(0,r.jsx)(t.img,{alt:"Google Client ID on Web3Auth Dashboard",src:n(60571).Z+"",width:"3220",height:"2764"})]}),"\n",(0,r.jsxs)(t.li,{children:["Click on ",(0,r.jsx)(t.code,{children:"Create"})," button to create your verifier. It may take up to 10-20 minutes to deploy verifier on ",(0,r.jsx)(t.em,{children:"testnet"}),". You'll receive an email once\nit's complete."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:["You will require the ",(0,r.jsx)(t.code,{children:"verifierName"})," of the newly created verifier."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"setting-up-your-react-project",children:"Setting up your React Project"}),"\n",(0,r.jsx)(t.p,{children:"We will need to use service workers while implementing the tKey SDK to handle the redirect login flow. This can be done by using a progressive react\napplication."}),"\n",(0,r.jsx)(t.p,{children:"For a new project, get started with the following command:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"npx create-react-app tkey-mpc-demo --template cra-template-pwa-typescript\ncd tkey-mpc-demo\n"})}),"\n",(0,r.jsx)(t.p,{children:"For an existing project, add a service worker."}),"\n",(0,r.jsx)(t.h3,{id:"setting-up-the-service-worker",children:"Setting up the service worker"}),"\n",(0,r.jsx)(t.p,{children:"Further, we need to setup the service worker according to our needs of the project, i.e handling the redirect login flow. Service worker basically\nsits between the frontend application, browser and the network. For the simplicity of this guide, we have added a boilerplate code. The easiest way to\ndo that is as follows"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"mkdir public/serviceworker\nwget https://github.com/Web3Auth/web3auth-core-kit-examples/blob/main/tkey/tkey-react-popup-example/public/serviceworker/sw.js -O public/serviceworker/sw.js\n"})}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:["For polyfill issues and BigInt issue, please checkout the ",(0,r.jsx)(t.a,{href:"/troubleshooting/webpack-issues",children:"troubleshooting page"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["For this guide, we'll be using a React application to demonstrate how the Web3Auth MPC SDK works. You can use any other framework of your choice using\nany other Web3Auth ",(0,r.jsx)(t.a,{href:"./",children:"Guides"})," / ",(0,r.jsx)(t.a,{href:"/examples",children:"Examples"}),". Just modify the functions to make it work."]}),"\n",(0,r.jsx)(t.h2,{id:"installation",children:"Installation"}),"\n",(0,r.jsxs)(t.p,{children:["We will be starting with a 2/2 flow, i.e ",(0,r.jsx)(t.code,{children:"Factor1: Social Factor"})," and ",(0,r.jsx)(t.code,{children:"Factor2: Device Factor"}),". Please note that this terminology is different from\nour conventional terminology of Shares A and B since we will not be constructing the private key in the frontend. Instead, we will be using the these\n",(0,r.jsx)(t.strong,{children:"Factors"})," stored in the different locations to make a final signature."]}),"\n",(0,r.jsxs)(t.p,{children:["For this project, we will be using the ",(0,r.jsx)(t.code,{children:"@tkey-mpc/default"})," package alongside multiple helper packages, that contain all the needed functionalities of\nthe tKey MPC SDK. We will be using the following packages highlighted in the package.json file:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-json",metastring:'title="package.json"',children:'{\n...\n"dependencies": {\n    //highlight-start\n    "@ethereumjs/common": "^3.1.1",\n\t\t"@ethereumjs/tx": "^4.1.1",\n    //highlight-end\n    "@testing-library/jest-dom": "^5.16.5",\n\t\t"@testing-library/react": "^13.4.0",\n\t\t"@testing-library/user-event": "^13.5.0",\n    //highlight-start\n    "@tkey-mpc/common-types": "^8.1.0",\n\t\t"@tkey-mpc/core": "^8.1.0",\n\t\t"@tkey-mpc/service-provider-torus": "^8.1.0",\n\t\t"@tkey-mpc/share-serialization": "^8.1.0",\n\t\t"@tkey-mpc/storage-layer-torus": "^8.1.0",\n\t\t"@toruslabs/constants": "^10.0.0",\n\t\t"@toruslabs/eslint-config-typescript": "^2.0.0",\n\t\t"@toruslabs/fnd-base": "^12.0.0",\n\t\t"@toruslabs/torus.js": "^10.0.5",\n\t\t"@toruslabs/tss-client": "^1.6.1-alpha.0",\n\t\t"@toruslabs/tss-lib": "^1.6.0-alpha.0",\n\t\t"@web3auth-mpc/ethereum-provider": "^2.1.22",\n\t\t"@web3auth/base": "^6.1.7",\n\t\t"@web3auth/ethereum-provider": "^6.1.7",\n\t\t"bn.js": "^5.2.1",\n\t\t"copy-webpack-plugin": "^11.0.0",\n\t\t"eccrypto": "^1.1.6",\n\t\t"html-webpack-plugin": "^5.5.0",\n\t\t"jsrsasign": "^10.6.1",\n\t\t"keccak256": "^1.0.6",\n    //highlight-end\n    "react": "^18.2.0",\n\t\t"react-dom": "^18.2.0",\n\t\t"react-scripts": "5.0.1",\n\t\t"sweetalert": "^2.1.2",\n\t\t"typescript": "^4.9.3",\n\t\t"web-vitals": "^2.1.4",\n    //highlight-next-line\n\t\t"web3": "^1.8.2"\n  },\n  "devDependencies": {\n    //highlight-start\n    "@types/eccrypto": "^1.1.3",\n\t\t"@types/elliptic": "^6.4.14",\n\t\t"@types/jsrsasign": "^10.5.5",\n    //highlight-end\n    "@types/jest": "^27.5.2",\n\t\t"@types/node": "^17.0.45",\n\t\t"@types/react": "^18.0.25",\n\t\t"@types/react-dom": "^18.0.9",\n    "assert": "^2.0.0",\n\t\t"buffer": "^6.0.3",\n\t\t"browserify-zlib": "^0.2.0",\n\t\t"crypto-browserify": "^3.12.0",\n\t\t"https-browserify": "^1.0.0",\n\t\t"os-browserify": "^0.3.0",\n\t\t"process": "^0.11.10",\n\t\t"react-app-rewired": "^2.2.1",\n\t\t"stream-browserify": "^3.0.0",\n\t\t"stream-http": "^3.2.0",\n\t\t"url": "^0.11.0",\n\t\t"workbox-background-sync": "^6.5.4",\n\t\t"workbox-broadcast-update": "^6.5.4",\n\t\t"workbox-cacheable-response": "^6.5.4",\n\t\t"workbox-core": "^6.5.4",\n\t\t"workbox-expiration": "^6.5.4",\n\t\t"workbox-google-analytics": "^6.5.4",\n\t\t"workbox-navigation-preload": "^6.5.4",\n\t\t"workbox-precaching": "^6.5.4",\n\t\t"workbox-range-requests": "^6.5.4",\n\t\t"workbox-routing": "^6.5.4",\n\t\t"workbox-strategies": "^6.5.4",\n\t\t"workbox-streams": "^6.5.4"\n  },\n  ...\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["These packages are quite similar to our current tKey JS SDK, however contain some additional parameters and functions needed for MPC. You can also\nrefer to our ",(0,r.jsx)(t.a,{href:"/sdk/core-kit/tkey",children:"tKey JS SDK Reference"})," for more details on the conventional functions involved."]}),"\n",(0,r.jsx)(t.h3,{id:"understanding-the-dependencies",children:"Understanding the Dependencies"}),"\n",(0,r.jsx)(t.h6,{id:"tkey-mpc",children:(0,r.jsx)(t.code,{children:"@tkey-mpc/*"})}),"\n",(0,r.jsx)(t.p,{children:"Contains all the functionalities of tKey needed for using MPC. These packages help us create the device factor and login to the Web3Auth."}),"\n",(0,r.jsx)(t.h6,{id:"toruslabs",children:(0,r.jsx)(t.code,{children:"@toruslabs/*"})}),"\n",(0,r.jsx)(t.p,{children:"Contains all the helper packages developed by Web3Auth/ Torus Labs for MPC implmentation."}),"\n",(0,r.jsxs)(t.h6,{id:"bnjs-eccrypto-jsrsasign-keccak256",children:[(0,r.jsx)(t.code,{children:"bn.js"}),", ",(0,r.jsx)(t.code,{children:"eccrypto"}),", ",(0,r.jsx)(t.code,{children:"jsrsasign"}),", ",(0,r.jsx)(t.code,{children:"keccak256"})]}),"\n",(0,r.jsx)(t.p,{children:"These packages help in key generation and signatures."}),"\n",(0,r.jsxs)(t.h6,{id:"web3auth-mpcethereum-provider-web3-ethereumjs",children:[(0,r.jsx)(t.code,{children:"@web3auth-mpc/ethereum-provider"}),", ",(0,r.jsx)(t.code,{children:"web3"}),", ",(0,r.jsx)(t.code,{children:"@ethereumjs/*"})]}),"\n",(0,r.jsx)(t.p,{children:"These packages help in connecting to the Ethereum network and creating transactions."}),"\n",(0,r.jsx)(t.h2,{id:"initialization",children:"Initialization"}),"\n",(0,r.jsx)(t.p,{children:"After Installation, the next step to use Web3Auth Core Kit tKey SDK is to Initialize the SDK."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",metastring:'title="src/tkey.ts"',children:'import ThresholdKey from "@tkey-mpc/core";\nimport { TorusServiceProvider } from "@tkey-mpc/service-provider-torus";\nimport { TorusStorageLayer } from "@tkey-mpc/storage-layer-torus";\nimport { ShareSerializationModule } from "@tkey-mpc/share-serialization";\n\n// Configuration of Service Provider\nconst torusSp = new TorusServiceProvider({\n  useTSS: true,\n  customAuthArgs: {\n    network: "sapphire_devnet",\n    web3AuthClientId: "YOUR_CLIENT_ID", // anything will work on localhost, but get one valid clientID before hosting, from https://dashboard.web3auth.io\n    baseUrl: `${window.location.origin}/serviceworker`,\n    enableLogging: true,\n  },\n});\n\n// Configuration of Metadata Storage Layer\nconst storageLayer = new TorusStorageLayer({\n  hostUrl: "https://sapphire-dev-2-1.authnetwork.dev/metadata",\n  enableLogging: true,\n});\n\n// Configuration of Share Serialization Module\nconst shareSerializationModule = new ShareSerializationModule();\n\n// Instantiation of tKey\nexport const tKey = new ThresholdKey({\n  enableLogging: true,\n  serviceProvider: torusSp as any,\n  storageLayer: storageLayer as any,\n  manualSync: true,\n  modules: {\n    shareSerialization: shareSerializationModule,\n  },\n});\n'})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",metastring:'title="src/App.tsx"',children:"useEffect(() => {\n  const init = async () => {\n    // Initialization of Service Provider\n    try {\n      await (tKey.serviceProvider as any).init();\n    } catch (error) {\n      console.error(error);\n    }\n  };\n  init();\n}, []);\n"})}),"\n",(0,r.jsx)(t.h3,{id:"adding-the-mpc-utils-file",children:"Adding the MPC utils file"}),"\n",(0,r.jsxs)(t.p,{children:["We have created an ",(0,r.jsx)(t.code,{children:"utils.ts"})," file to help us with the MPC functionalities. You can directly copy this file from our\n",(0,r.jsx)(t.a,{href:"https://raw.githubusercontent.com/tkey/tkey-mpc-examples/main/tkey-mpc-web/tkey-mpc-react-popup-example/src/utils.ts",children:"GitHub Example"})," or the code\nbelow."]}),"\n",(0,r.jsx)(o,{}),"\n",(0,r.jsx)(t.h2,{id:"triggering-login-using-service-provider",children:"Triggering Login using Service Provider"}),"\n",(0,r.jsxs)(t.p,{children:["Once you have initialized the Web3Auth Service Provider, you're ready to trigger the login process. This is a needed step since this will generate a\nprivate key which will be needed by the tKey to generate it's share. This is done by calling the ",(0,r.jsx)(t.code,{children:"triggerLogin()"})," function within the ",(0,r.jsx)(t.code,{children:"tKey"}),"\ninstance's of ",(0,r.jsx)(t.code,{children:"serviceProvider"})," property."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'const triggerLogin = async () => {\n  if (!tKey) {\n    uiConsole("tKey not initialized yet");\n    return;\n  }\n  try {\n    // Triggering Login using Service Provider ==> opens the popup\n    const loginResponse = await (tKey.serviceProvider as any).triggerLogin({\n      typeOfLogin: "google",\n      verifier: "google-tkey-w3a",\n      clientId: "774338308167-q463s7kpvja16l4l0kko3nb925ikds2p.apps.googleusercontent.com",\n    });\n    console.log("loginResponse", loginResponse);\n\n    setLoginResponse(loginResponse);\n    setUser(loginResponse.userInfo);\n    return loginResponse;\n  } catch (error) {\n    uiConsole(error);\n  }\n};\n'})}),"\n",(0,r.jsx)(t.h2,{id:"initialize-tkey",children:"Initialize tKey"}),"\n",(0,r.jsx)(t.p,{children:"Once you have triggered the login process, you're ready to initialize the tKey. This will generate you a Metadata Key corresponding to your login\nprovider, which helps the SDK detect the login of the user. Additionally. we'll generate the device (factor2) factor and store/retrieve it from the\nlocal storage helping us to setup the 2/2 basic flow to make transactions."}),"\n",(0,r.jsx)(t.h3,{id:"check-if-user-is-new-or-existing",children:"Check if user is new or existing"}),"\n",(0,r.jsxs)(t.p,{children:["The Web3Auth Metadata stores the information about the user's key locations, like how many keys are generated, which factorPub represents which key\naccording to the set description etc. You can customise what information you want to store in the metadata. The utils file we created earlier has a\nfunction called ",(0,r.jsx)(t.code,{children:"addFactorKeyMetadata"})," which is used to add data in the metadata, you can customise that according to your needs."]}),"\n",(0,r.jsxs)(t.p,{children:["By default, if the key is not present, the metadata returns a ",(0,r.jsx)(t.code,{children:"KEY_NOT_FOUND"})," message. We can use this to check if the user is new or existing."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'const isMetadataPresent = async (privateKeyBN: BN) => {\n  const metadata = await tKey.storageLayer.getMetadata({ privKey: privateKeyBN });\n  if (metadata && Object.keys(metadata).length > 0 && (metadata as any).message !== "KEY_NOT_FOUND") {\n    return true;\n  } else {\n    return false;\n  }\n};\n'})}),"\n",(0,r.jsx)(t.h3,{id:"store-tkey-device-factor-in-local-storage",children:"Store tKey device factor in local storage"}),"\n",(0,r.jsx)(t.p,{children:"Since we are use the tKey Core MPC SDK, we need to implement the device storage functions ourselves. We'll be using the local storage to store the\ndevice share for this example."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'import BN from "bn.js";\n\nconst [localFactorKey, setLocalFactorKey] = useState<BN | null>(null);\n\nuseEffect(() => {\n  if (!localFactorKey) return;\n  localStorage.setItem(\n    `tKeyLocalStore\\u001c${loginResponse.userInfo.verifier}\\u001c${loginResponse.userInfo.verifierId}`,\n    JSON.stringify({\n      factorKey: localFactorKey.toString("hex"),\n      verifier: loginResponse.userInfo.verifier,\n      verifierId: loginResponse.userInfo.verifierId,\n    }),\n  );\n}, [localFactorKey]);\n'})}),"\n",(0,r.jsxs)(t.h3,{id:"implementing-the-main-initializenewkey-function",children:["Implementing the main ",(0,r.jsx)(t.code,{children:"initializeNewKey"})," function"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'import { addFactorKeyMetadata, getTSSPubKey } from "./utils";\nimport BN from "bn.js";\nimport { generatePrivate } from "eccrypto";\n\nconst [metadataKey, setMetadataKey] = useState<any>();\nconst [localFactorKey, setLocalFactorKey] = useState<BN | null>(null);\nconst [oAuthShare, setOAuthShare] = useState<any>(null);\nconst [signingParams, setSigningParams] = useState<any>(null);\n\nconst initializeNewKey = async () => {\n  if (!tKey) {\n    uiConsole("tKey not initialized yet");\n    return;\n  }\n  try {\n    // Trigger Login using Service Provider\n    const loginResponse = await triggerLogin();\n\n    const OAuthShare = new BN(TorusUtils.getPostboxKey(loginResponse), "hex");\n    setOAuthShare(OAuthShare); // This private key is the OAuth Metadata Share\n\n    // Filter out the null values from the signatures\n    const signatures = loginResponse.sessionData.sessionTokenData\n      .filter((i) => Boolean(i))\n      .map((session) => JSON.stringify({ data: session.token, sig: session.signature }));\n\n    // Get the Device Share\n    const tKeyLocalStoreString = localStorage.getItem(\n      `tKeyLocalStore\\u001c${loginResponse.userInfo.verifier}\\u001c${loginResponse.userInfo.verifierId}`,\n    );\n    const tKeyLocalStore = JSON.parse(tKeyLocalStoreString || "{}");\n\n    // Define the factorKey variable for later usage. Please note that this factorKey represents the factorKey 2, ie. device share or recovery share in the 2/2 flow\n    let factorKey: BN | null = null;\n\n    // Check if the user is new or existing\n    const existingUser = await isMetadataPresent(OAuthShare);\n\n    if (!existingUser) {\n      // If the user is new, we\'ll generate a new factorKey & deviceShare and store it in the local storage. The factorKey can be used to get the deviceShare from metadata. Device Share is stored on the metadata encrypted by the factorKey.\n      factorKey = new BN(generatePrivate());\n      const deviceTSSShare = new BN(generatePrivate());\n      const deviceTSSIndex = 2;\n      const factorPub = getPubKeyPoint(factorKey);\n      await tKey.initialize({ useTSS: true, factorPub, deviceTSSShare, deviceTSSIndex });\n    } else {\n      if (tKeyLocalStore.verifier === loginResponse.userInfo.verifier && tKeyLocalStore.verifierId === loginResponse.userInfo.verifierId) {\n        // If the user is existing and the local storage has the factorKey corresponding the logged in user, we\'ll use that factorKey to get the deviceShare from metadata. Device Share is stored on the metadata encrypted by the factorKey.\n        factorKey = new BN(tKeyLocalStore.factorKey, "hex");\n      } else {\n        // If the user is existing but the local storage doesn\'t have the factorKey corresponding the logged in user, we\'ll ask the user to enter the backup factor key to get the deviceShare from metadata.\n        try {\n          factorKey = await swal("Enter your backup share", {\n            content: "input" as any,\n          }).then(async (value) => {\n            uiConsole(value);\n            return await (tKey.modules.shareSerialization as any).deserialize(value, "mnemonic");\n          });\n        } catch (error) {\n          uiConsole(error);\n          throw new Error("Invalid backup share");\n        }\n      }\n      // if the factorKey is null, it means the user entered an invalid backup share\n      if (factorKey === null) throw new Error("Backup share not found");\n\n      // Get the corresponding TSS share from metadata using the factorKey\n      const factorKeyMetadata = await tKey.storageLayer.getMetadata<{\n        message: string;\n      }>({\n        privKey: factorKey,\n      });\n\n      // If the metadata doesn\'t have the TSS Share, it means the user has entered an invalid backup share\n      if (factorKeyMetadata.message === "KEY_NOT_FOUND") {\n        throw new Error("no metadata for your factor key, reset your account");\n      }\n      const metadataShare = JSON.parse(factorKeyMetadata.message);\n      if (!metadataShare.deviceShare || !metadataShare.tssShare) throw new Error("Invalid data from metadata");\n\n      const metadataDeviceShare = metadataShare.deviceShare;\n\n      // Initialize the tKey with the TSS Share from metadata\n      await tKey.initialize({ neverInitializeNewKey: true });\n      await tKey.inputShareStoreSafe(metadataDeviceShare, true);\n    }\n\n    // Checks the requiredShares to reconstruct the tKey, starts from 2 by default and each of the above share reduce it by one.\n    const { requiredShares } = tKey.getKeyDetails();\n    if (requiredShares > 0) {\n      throw `Threshold not met. Required Share: ${requiredShares}. You should reset your account.`;\n    }\n    // Reconstruct the Metadata Key\n    const metadataKey = await tKey.reconstructKey();\n    setMetadataKey(metadataKey?.privKey.toString("hex"));\n\n    const tssNonce: number = tKey.metadata.tssNonces![tKey.tssTag];\n    // tssShare1 = TSS Share from the social login/ service provider\n    const tssShare1PubKeyDetails = await tKey.serviceProvider.getTSSPubKey(tKey.tssTag, tssNonce);\n    const tssShare1PubKey = { x: tssShare1PubKeyDetails.x.toString("hex"), y: tssShare1PubKeyDetails.y.toString("hex") };\n\n    // tssShare2 = TSS Share from the local storage of the device\n    const { tssShare: tssShare2, tssIndex: tssShare2Index } = await tKey.getTSSShare(factorKey);\n\n    // derive tss pub key, tss pubkey is implicitly formed using the dkgPubKey and the userShare (as well as userTSSIndex)\n    const tssPubKey = getTSSPubKey(tssShare1PubKey, tssShare2, tssShare2Index);\n    const compressedTSSPubKey = Buffer.from(`${tssPubKey.getX().toString(16, 64)}${tssPubKey.getY().toString(16, 64)}`, "hex");\n\n    // save factor key and other metadata on local storage\n    if (\n      !existingUser ||\n      !(tKeyLocalStore.verifier === loginResponse.userInfo.verifier && tKeyLocalStore.verifierId === loginResponse.userInfo.verifierId)\n    ) {\n      await addFactorKeyMetadata(tKey, factorKey, tssShare2, tssShare2Index, "local storage share");\n    }\n    await tKey.syncLocalMetadataTransitions();\n\n    setLocalFactorKey(factorKey);\n\n    const nodeDetails = await tKey.serviceProvider.getTSSNodeDetails();\n\n    // Set Signing Params for the Web3 Provider\n    setSigningParams({\n      tssNonce,\n      tssShare2,\n      tssShare2Index,\n      compressedTSSPubKey,\n      signatures,\n      nodeDetails,\n    });\n\n    // All done!\n    uiConsole(\n      "Successfully logged in & initialized MPC TKey SDK",\n      "TSS Public Key: ",\n      tKey.getTSSPub(),\n      "Metadata Key",\n      metadataKey.privKey.toString("hex"),\n      "With Factors/Shares:",\n      tKey.getMetadata().getShareDescription(),\n    );\n  } catch (error) {\n    uiConsole(error, "caught");\n  }\n};\n'})}),"\n",(0,r.jsx)(t.h4,{id:"setup-web3-provider",children:"Setup Web3 Provider"}),"\n",(0,r.jsx)(t.p,{children:"Once you have set up your tKey instance, you're ready to set up the Web3 Provider. This is the provider that will be used by the Web3 SDK to sign the\ntransactions."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'import { setupWeb3 } from "./utils";\n\nconst [web3, setWeb3] = useState<any>(null);\nconst [signingParams, setSigningParams] = useState<any>(null);\n\nuseEffect(() => {\n  const localSetup = async () => {\n    const chainConfig = {\n      chainId: "0xaa36a7",\n      rpcTarget: "https://rpc.ankr.com/eth_sepolia",\n      displayName: "Ethereum Sepolia",\n      blockExplorer: "https://sepolia.etherscan.io",\n      ticker: "ETH",\n      tickerName: "Ethereum",\n    };\n    const web3Local = await setupWeb3(chainConfig, loginResponse, signingParams);\n    setWeb3(web3Local);\n  };\n  if (signingParams) {\n    localSetup();\n  }\n}, [signingParams]);\n'})}),"\n",(0,r.jsx)(t.h2,{id:"copy-the-local-tss-share-into-a-manual-backup-factor-key",children:"Copy the Local TSS Share into a Manual Backup Factor Key"}),"\n",(0,r.jsx)(t.p,{children:"The following code snippet shows how to copy the local TSS share into a manual backup factor key. This is useful if you want to create a backup of\nyour device share, without generating new TSS Shares. Generation of new TSS shares by default has been limited to 3 at the moment. This is to help\nsave processing time and enhance the user experience."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'import { copyExistingTSSShareForNewFactor, addFactorKeyMetadata } from "./utils";\n\nconst copyTSSShareIntoManualBackupFactorkey = async () => {\n  try {\n    if (!tKey) {\n      throw new Error("tkey does not exist, cannot add factor pub");\n    }\n    if (!localFactorKey) {\n      throw new Error("localFactorKey does not exist, cannot add factor pub");\n    }\n\n    const backupFactorKey = new BN(generatePrivate());\n    const backupFactorPub = getPubKeyPoint(backupFactorKey);\n\n    await copyExistingTSSShareForNewFactor(tKey, backupFactorPub, localFactorKey);\n\n    const { tssShare: tssShare2, tssIndex: tssIndex2 } = await tKey.getTSSShare(localFactorKey);\n    await addFactorKeyMetadata(tKey, backupFactorKey, tssShare2, tssIndex2, "manual share");\n    const serializedShare = await (tKey.modules.shareSerialization as any).serialize(backupFactorKey, "mnemonic");\n    await tKey.syncLocalMetadataTransitions();\n    uiConsole("Successfully created manual backup. Manual Backup Factor: ", serializedShare);\n  } catch (err) {\n    uiConsole(`Failed to copy share to new manual factor: ${err}`);\n  }\n};\n'})}),"\n",(0,r.jsx)(t.h2,{id:"create-new-tss-share-into-a-manual-backup-factor-key",children:"Create new TSS Share into a Manual Backup Factor Key"}),"\n",(0,r.jsx)(t.p,{children:"The following code snippet shows how to create a new TSS share into a manual backup factor key."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'import { addNewTSSShareAndFactor, addFactorKeyMetadata } from "./utils";\n\nconst createNewTSSShareIntoManualBackupFactorkey = async () => {\n  try {\n    if (!tKey) {\n      throw new Error("tkey does not exist, cannot add factor pub");\n    }\n    if (!localFactorKey) {\n      throw new Error("localFactorKey does not exist, cannot add factor pub");\n    }\n\n    const backupFactorKey = new BN(generatePrivate());\n    const backupFactorPub = getPubKeyPoint(backupFactorKey);\n    const tKeyShareDescriptions = await tKey.getMetadata().getShareDescription();\n    let backupFactorIndex = 2;\n    for (const [key, value] of Object.entries(tKeyShareDescriptions)) {\n      console.log(`value of share ${key}`, value);\n      // eslint-disable-next-line no-loop-func, array-callback-return\n      value.map((factor: any) => {\n        factor = JSON.parse(factor);\n        if (factor.tssShareIndex > backupFactorIndex) {\n          backupFactorIndex = factor.tssShareIndex;\n          console.log(`backupFactorIndex of share ${key}`, backupFactorIndex);\n        }\n      });\n    }\n    uiConsole("backupFactorIndex:", backupFactorIndex + 1);\n    await addNewTSSShareAndFactor(tKey, backupFactorPub, backupFactorIndex + 1, localFactorKey, signingParams.signatures);\n\n    const { tssShare: tssShare2, tssIndex: tssIndex2 } = await tKey.getTSSShare(backupFactorKey);\n    await addFactorKeyMetadata(tKey, backupFactorKey, tssShare2, tssIndex2, "manual share");\n    const serializedShare = await (tKey.modules.shareSerialization as any).serialize(backupFactorKey, "mnemonic");\n\n    await tKey.syncLocalMetadataTransitions();\n    uiConsole(" Successfully created manual backup.Manual Backup Factor: ", serializedShare);\n  } catch (err) {\n    uiConsole(`Failed to create new manual factor ${err}`);\n  }\n};\n'})}),"\n",(0,r.jsx)(t.h2,{id:"get-key-details",children:"Get Key Details"}),"\n",(0,r.jsx)(t.p,{children:"The following code snippet will help you get the details of the key stored on the metadata server. Please note these details can be customised and\nstored according to your needs."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-tsx",children:'const keyDetails = async () => {\n  if (!tKey) {\n    uiConsole("tKey not initialized yet");\n    return;\n  }\n  // const keyDetails = await tKey.getKeyDetails();\n\n  uiConsole("TSS Public Key: ", tKey.getTSSPub(), "With Factors/Shares:", tKey.getMetadata().getShareDescription());\n  // return keyDetails;\n};\n'})}),"\n",(0,r.jsx)(t.h2,{id:"interacting-with-blockchain",children:"Interacting with Blockchain"}),"\n",(0,r.jsx)(t.p,{children:"Once you are done with the setting of the web3 provider, you can use it to make blockchain calls. This can be used with any EVM compatible chain"}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsxs)(t.p,{children:["You can checkout our ",(0,r.jsx)(t.a,{href:"/connect-blockchain",children:"Connect Blockchain"})," documentation which has a detailed guide on how to connect to major blockchains out\nthere."]})}),"\n",(0,r.jsx)(t.h2,{id:"example-code",children:"Example code"}),"\n",(0,r.jsxs)(t.p,{children:["The code for the application we developed in this guide can be found in the\n",(0,r.jsx)(t.a,{href:"https://github.com/tkey/tkey-mpc-examples/tree/main/tkey-mpc-web/tkey-mpc-react-popup-example",children:"examples repository"}),". Check it out and try running it\nlocally yourself!"]}),"\n",(0,r.jsx)(t.h2,{id:"questions",children:"Questions?"}),"\n",(0,r.jsxs)(t.p,{children:["Ask us on ",(0,r.jsx)(t.a,{href:"https://web3auth.io/community",children:"Web3Auth's Community Support Portal"})]})]})}function y(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(g,{...e})}):g(e)}},30831:(e,t,n)=>{n.d(t,{Z:()=>s});var r=n(35742),a=n(85893);function s(e){const{title:t,description:n,image:s,slug:o,keywords:i}=e;return(0,a.jsxs)(r.Z,{children:[t?(0,a.jsxs)("title",{children:[t," | Web3Auth "]}):(0,a.jsx)("title",{children:"Documentation | Web3Auth"}),n?(0,a.jsx)("meta",{name:"description",content:n}):(0,a.jsx)("meta",{name:"description",content:"Web3Auth is simple, non-custodial auth infrastructure that enables Web3 wallets and applications to provide seamless user logins for both mainstream and native Web3 users."}),i?i.length>0&&(0,a.jsx)("meta",{name:"keywords",content:`web3auth, blockchain, solana, ethereum, multi party computation, ${i.join(", ")}`}):(0,a.jsx)("meta",{name:"keywords",content:"web3auth, blockchain, web3, web3.js, ethers.js, solana, ethereum, passwordless, passwordless magic link, multi party computation, tkey, torus, web3 auth, auth"}),(0,a.jsx)("meta",{property:"og:site_name",content:"Web3Auth"}),(0,a.jsx)("meta",{property:"og:type",content:"website"}),t?(0,a.jsx)("meta",{property:"og:title",content:t}):(0,a.jsx)("meta",{property:"og:title",content:"Documentation | Web3Auth"}),n?(0,a.jsx)("meta",{property:"og:description",content:n}):(0,a.jsx)("meta",{property:"og:description",content:"Web3Auth is simple, non-custodial auth infrastructure that enables Web3 wallets and applications to provide seamless user logins for both mainstream and native Web3 users."}),o?(0,a.jsx)("meta",{property:"og:url",content:`https://web3auth.io/docs${o}`}):(0,a.jsx)("meta",{property:"og:url",content:"https://web3auth.io/docs"}),s?(0,a.jsx)("meta",{property:"og:image",content:s}):(0,a.jsx)("meta",{property:"og:image",content:"http://web3auth.io/docs/images/docs-meta-cards/documentation-card.png"}),(0,a.jsx)("meta",{name:"twitter:card",content:"summary_large_image"}),(0,a.jsx)("meta",{name:"twitter:site",content:"@Web3Auth"}),(0,a.jsx)("meta",{name:"twitter:creator",content:"@Web3Auth"}),s?(0,a.jsx)("meta",{name:"twitter:image",content:s}):(0,a.jsx)("meta",{name:"twitter:image",content:"http://web3auth.io/docs/images/docs-meta-cards/documentation-card.png"}),t?(0,a.jsx)("meta",{itemProp:"name",content:t}):(0,a.jsx)("meta",{itemProp:"name",content:"Documentation | Web3Auth"}),n?(0,a.jsx)("meta",{itemProp:"description",content:n}):(0,a.jsx)("meta",{itemProp:"description",content:"Web3Auth is simple, non-custodial auth infrastructure that enables Web3 wallets and applications to provide seamless user logins for both mainstream and native Web3 users."}),s?(0,a.jsx)("meta",{itemProp:"image",content:s}):(0,a.jsx)("meta",{itemProp:"image",content:"http://web3auth.io/docs/images/docs-meta-cards/documentation-card.png"}),(0,a.jsx)("meta",{name:"author",content:"Web3Auth"})]})}},32165:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/tkey-mpc-flow-e533ca27fe7b9edcc8bcdb3667bd2f80.png"},37392:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/google-app-redirect-uri-5de760ce07053974b124ec811e21f5fc.png"},60571:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/google-verifier-110bc264fddbbea4a47044e81e18f27f.png"},59611:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/login-providers-list-a7226c97c4c45f24c44ec4523e92fa93.png"},11151:(e,t,n)=>{n.d(t,{Z:()=>i,a:()=>o});var r=n(67294);const a={},s=r.createContext(a);function o(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);