"use strict";(self.webpackChunkweb3auth_docs=self.webpackChunkweb3auth_docs||[]).push([[72937],{55023:(e,r,s)=>{s.r(r),s.d(r,{assets:()=>a,contentTitle:()=>i,default:()=>p,frontMatter:()=>t,metadata:()=>d,toc:()=>c});var n=s(85893),o=s(11151);const t={title:"Providers - Web3Auth",sidebar_label:"Providers",displayed_sidebar:"sdk",description:"Web3Auth Providers | Documentation - Web3Auth"},i=void 0,d={id:"sdk/helper-sdks/providers/providers",title:"Providers - Web3Auth",description:"Web3Auth Providers | Documentation - Web3Auth",source:"@site/docs/sdk/helper-sdks/providers/providers.mdx",sourceDirName:"sdk/helper-sdks/providers",slug:"/sdk/helper-sdks/providers/",permalink:"/docs/sdk/helper-sdks/providers/",draft:!1,unlisted:!1,editUrl:"https://github.com/web3auth/web3auth-docs/edit/master/docs/sdk/helper-sdks/providers/providers.mdx",tags:[],version:"current",frontMatter:{title:"Providers - Web3Auth",sidebar_label:"Providers",displayed_sidebar:"sdk",description:"Web3Auth Providers | Documentation - Web3Auth"},sidebar:"sdk",previous:{title:"Pregenerated Wallets API",permalink:"/docs/sdk/wallet-services/pregenerate-wallet"},next:{title:"EIP1193 (EVM) Provider",permalink:"/docs/sdk/helper-sdks/providers/evm"}},a={},c=[{value:"Base Type Reference for Web3Auth Providers",id:"base-type-reference-for-web3auth-providers",level:2}];function l(e){const r={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.p,{children:"Providers are basically pre configured RPC clients for different blockchains. They are used to interact with the blockchain network. Web3Auth provides\nyou with a few common providers for EVM compatible chains and Solana Blockchain. You can also use the private key of the user to connect to other\nblockchain networks, in case of SSS based infrastructure. For MPC, you can only use the dedicated providers provided by Web3Auth."}),"\n",(0,n.jsx)(r.p,{children:"Currently, Web3Auth supports the following providers:"}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/sdk/helper-sdks/providers/evm",children:"EIP1193 Provider for EVM Compatible Chains"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/sdk/helper-sdks/providers/solana",children:"Solana Provider for Solana Blockchain"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/sdk/helper-sdks/providers/xrpl",children:"XRPL Provider for XRPL Blockchain"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"/sdk/helper-sdks/providers/common",children:"Common Provider for Other Blockchains"})}),"\n"]}),"\n",(0,n.jsx)(r.h2,{id:"base-type-reference-for-web3auth-providers",children:"Base Type Reference for Web3Auth Providers"}),"\n",(0,n.jsxs)(r.p,{children:["For facilitating these providers, Web3Auth exposes a ",(0,n.jsx)(r.code,{children:"IProvider"})," which is a provider type helping you make standardized RPC calls to a blockchain."]}),"\n",(0,n.jsxs)(r.p,{children:["This provider contains two functions, ",(0,n.jsx)(r.code,{children:"send"})," and ",(0,n.jsx)(r.code,{children:"request"}),". You can find its type reference below:"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-tsx",children:'export interface IProvider extends SafeEventEmitter {\n  sendAsync: <T, IProvider=> Promise<U>;\n  send: <T, U>(req: JRPCRequest<T>, callback: SendCallBack<U>) => void;\n  request: <T>(args: RequestArguments) => Promise<Maybe<T>>;\n}\n\nexport interface JRPCRequest<T> extends JRPCBase {\n  method: string;\n  params?: T;\n}\nexport interface JRPCBase {\n  jsonrpc?: JRPCVersion;\n  id?: JRPCId;\n}\nexport declare type JRPCVersion = "2.0";\nexport declare type JRPCId = number | string | void;\nexport interface RequestArguments {\n  method: string;\n  params?: unknown[] | object;\n}\n'})})]})}function p(e={}){const{wrapper:r}={...(0,o.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},11151:(e,r,s)=>{s.d(r,{Z:()=>d,a:()=>i});var n=s(67294);const o={},t=n.createContext(o);function i(e){const r=n.useContext(t);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function d(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),n.createElement(t.Provider,{value:r},e.children)}}}]);