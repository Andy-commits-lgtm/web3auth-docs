"use strict";(self.webpackChunkweb3auth_docs=self.webpackChunkweb3auth_docs||[]).push([[93890],{62862:(e,s,a)=>{a.r(s),a.d(s,{assets:()=>h,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var t=a(85893),n=a(11151);const r={title:"Important Terms and Definitions",sidebar_label:"Glossary",displayed_sidebar:"docs",description:"Important Terms and Definitions - Web3Auth Wallet Management Infrastructure | Documentation - Web3Auth"},i=void 0,o={id:"infrastructure/glossary",title:"Important Terms and Definitions",description:"Important Terms and Definitions - Web3Auth Wallet Management Infrastructure | Documentation - Web3Auth",source:"@site/docs/infrastructure/glossary.mdx",sourceDirName:"infrastructure",slug:"/infrastructure/glossary",permalink:"/docs/infrastructure/glossary",draft:!1,unlisted:!1,editUrl:"https://github.com/web3auth/web3auth-docs/edit/master/docs/infrastructure/glossary.mdx",tags:[],version:"current",frontMatter:{title:"Important Terms and Definitions",sidebar_label:"Glossary",displayed_sidebar:"docs",description:"Important Terms and Definitions - Web3Auth Wallet Management Infrastructure | Documentation - Web3Auth"},sidebar:"docs",previous:{title:"Nodes and DKG",permalink:"/docs/infrastructure/nodes-and-dkg"},next:{title:"Introduction",permalink:"/docs/pnp/introduction"}},h={},c=[{value:"Shamir Secret Sharing (SSS)",id:"shamir-secret-sharing-sss",level:3},{value:"Verifiable Secret Sharing (VSS)",id:"verifiable-secret-sharing-vss",level:3},{value:"Threshold Signature Schemes (TSS)",id:"threshold-signature-schemes-tss",level:3},{value:"Distributed Key Generation (DKG)",id:"distributed-key-generation-dkg",level:3},{value:"Proactive Secret Sharing (PSS)",id:"proactive-secret-sharing-pss",level:3},{value:"Epochs",id:"epochs",level:3}];function l(e){const s={a:"a",annotation:"annotation",h3:"h3",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",p:"p",semantics:"semantics",span:"span",...(0,n.a)(),...e.components},{Details:a}=s;return a||function(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h3,{id:"shamir-secret-sharing-sss",children:"Shamir Secret Sharing (SSS)"}),"\n",(0,t.jsxs)(s.p,{children:["Shamir\u2019s secret sharing scheme is a polynomial threshold ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mo,{stretchy:"false",children:"["}),(0,t.jsx)(s.mo,{stretchy:"false",children:"("}),(0,t.jsx)(s.mi,{children:"t"}),(0,t.jsx)(s.mo,{separator:"true",children:","}),(0,t.jsx)(s.mi,{children:"n"}),(0,t.jsx)(s.mo,{stretchy:"false",children:")"}),(0,t.jsx)(s.mo,{stretchy:"false",children:"]"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"[(t,n)]"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(s.span,{className:"mopen",children:"[("}),(0,t.jsx)(s.span,{className:"mord mathnormal",children:"t"}),(0,t.jsx)(s.span,{className:"mpunct",children:","}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",children:"n"}),(0,t.jsx)(s.span,{className:"mclose",children:")]"})]})})]})," secret sharing scheme where a dealer divides a secret into n multiple shares and\neach participant is given a share by evaluating a polynomial of order ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsx)(s.mrow,{children:(0,t.jsx)(s.mi,{children:"t"})}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"t"})]})})}),(0,t.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"0.6151em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",children:"t"})]})})]})," . To reconstruct the secret, ",(0,t.jsxs)(s.span,{className:"katex",children:[(0,t.jsx)(s.span,{className:"katex-mathml",children:(0,t.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(s.semantics,{children:[(0,t.jsxs)(s.mrow,{children:[(0,t.jsx)(s.mi,{children:"t"}),(0,t.jsx)(s.mo,{children:"+"}),(0,t.jsx)(s.mn,{children:"1"})]}),(0,t.jsx)(s.annotation,{encoding:"application/x-tex",children:"t + 1"})]})})}),(0,t.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"0.6984em",verticalAlign:"-0.0833em"}}),(0,t.jsx)(s.span,{className:"mord mathnormal",children:"t"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,t.jsx)(s.span,{className:"mbin",children:"+"}),(0,t.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,t.jsxs)(s.span,{className:"base",children:[(0,t.jsx)(s.span,{className:"strut",style:{height:"0.6444em"}}),(0,t.jsx)(s.span,{className:"mord",children:"1"})]})]})]})," shares are required."]}),"\n",(0,t.jsxs)(s.p,{children:["SSS is a base fundemental in a lot of MPC cryptography and in Web3Auth\u2019s infrastucture. More can be read\n",(0,t.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing",children:"here"}),"."]}),"\n",(0,t.jsx)(s.h3,{id:"verifiable-secret-sharing-vss",children:"Verifiable Secret Sharing (VSS)"}),"\n",(0,t.jsx)(s.p,{children:"Verifiable secret sharing refers to Shamir secret sharing schemes where even in the presence of malicious dealers, there is a well-defined secret that\nthe participants can later reconstruct."}),"\n",(0,t.jsx)(s.h3,{id:"threshold-signature-schemes-tss",children:"Threshold Signature Schemes (TSS)"}),"\n",(0,t.jsxs)(s.p,{children:["Threshold signature schemes refer to signing schemes that allow a qualified set of parties involved in a secret sharing scheme to generate a signature\non a message without reconstructing the private key. The most well-known signature scheme is ",(0,t.jsx)(s.a,{href:"https://eprint.iacr.org/2019/114.pdf",children:"GG19"})," and an\nimplementation can be found ",(0,t.jsx)(s.a,{href:"https://github.com/ZenGo-X/multi-party-ecdsa",children:"here"}),". In particular Web3Auth supports and utilizes GG19, GG20, its EDDSA\nvariants, and DKLS19."]}),"\n",(0,t.jsx)(s.h3,{id:"distributed-key-generation-dkg",children:"Distributed Key Generation (DKG)"}),"\n",(0,t.jsxs)(s.p,{children:["Distributed key generation was introduced by Pedersen, and the key idea involves using n parallel runs of SSS or VSS to ensure that there is no dealer\nwho knows the secret. We generally use a varient of ",(0,t.jsx)(s.a,{href:"https://eprint.iacr.org/2002/134.pdf",children:"Async Verifiable Secret Sharing"})," in our DKG."]}),"\n",(0,t.jsxs)(a,{children:[(0,t.jsx)("summary",{children:"Async Verifiable Secret Sharing"}),(0,t.jsxs)("div",{children:[(0,t.jsx)("div",{children:(0,t.jsx)(s.p,{children:"The main advantage Async Verifiable Secret Sharing DKG has over the other well-known DKGs like Pedersen DKG, Feldman's VSS and its variants is\nthat it is fully asynchronous and thus does not require a complaint phase when we consider the allowance for a small zero-knowledge proof. This\nresults in a simpler implementation (with constant communication rounds even during malicious scenarios), but at the expense of message size."})}),(0,t.jsx)("br",{}),(0,t.jsx)("div",{children:(0,t.jsx)(s.p,{children:"In brief, this scheme generates a random bivariate polynomial (i.e. 2D surface) and creates horizontal (X) and vertical (Y) slices at the\nappropriate indices as sharings. We then get sub-sharings (points) on these horizontal and vertical sharings at the appropriate indices and echo\nthem to other nodes. As a node, the polynomial reconstructed from the sub-sharings received from other nodes should match up with the initial\nsharing that the node received from the dealer, and even if they do not, the node can always interpolate the correct sharing via these echoed\nsub-sharings. This eliminates the dealer complaint phase. We then we restrict ourselves to just the horizontal (X) domain such that our final\nsharings are still on that of a univariate polynomial, which is what a typical DKG does.\u200c"})}),(0,t.jsx)("br",{}),(0,t.jsx)("div",{children:(0,t.jsx)(s.p,{children:"At the end of the distributed key generation process, the nodes are left with a (polynomial) share to a master polynomial. This master\npolynomial is the sum of all the initial polynomials which were generated by each participating node. Since a threshold number of nodes\ncontributed to this master polynomial's randomness, it is not possible for any non-threshold subset of nodes to recover its coefficients."})}),(0,t.jsx)("br",{}),(0,t.jsx)("div",{children:"The constant coefficient of this master polynomial is the user's private key."})]})]}),"\n",(0,t.jsx)(s.h3,{id:"proactive-secret-sharing-pss",children:"Proactive Secret Sharing (PSS)"}),"\n",(0,t.jsx)(s.p,{children:"Proactive secret sharing allows participants to \u201crefresh\u201d shares, so that all participants receive new shares, but the secret remains unchanged. This\nallows the secret sharing to be secure against mobile adversaries who may be able to compromise all participants over the lifetime of the secret (eg.\nadversary hacks a random participant\u2019s server every month)."}),"\n",(0,t.jsx)(s.p,{children:"Simply copying shares across epochs is a bad idea, since a single node operator operating in two separate epochs would get access to two shares, and\nit also makes it not possible to increase or decrease the number of operators in each epoch. Hence, we use PSS to migrate shares across epochs."}),"\n",(0,t.jsxs)(s.p,{children:["We refer the user to a ",(0,t.jsx)(s.a,{href:"https://eprint.iacr.org/2002/134.pdf",children:"Proactive Secret Sharing Scheme"}),' that supports dynamic sets of participants, which we\nuse for share refresh. In brief, the key idea is that we create polynomial sharings of the existing key shares and add these polynomials in a specific\nway such that the coefficient of the master polynomial is the Lagrange interpolation of the existing key shares. Much like how DKGs are the sum of\nseveral secret sharings, where the master secret is the sum of all of the secrets from each of the N-parallel secret sharing protocols, we can do the\nsame thing by setting N-parallel secret sharing protocols to be run by the original set of nodes, with their "secret" as their share. The resulting\nshares of shares, if added appropriately (multiply them by Lagrange coefficients first), would lead to a re-sharing on the original secret.']}),"\n",(0,t.jsx)(s.h3,{id:"epochs",children:"Epochs"}),"\n",(0,t.jsx)(s.p,{children:"Torus nodes operate within a certain time period, called an epoch. Nodes within the same epoch are part of the same BFT (Byzantine Fault Tolerance)\nnetwork and hold key shares that are compatible with each others' key shares. Nodes within different epochs do not. The main purpose of epochs is to\nensure that node operators can be removed and added, and to minimize the impact of loss of key shares or node failures over time."})]})}function d(e={}){const{wrapper:s}={...(0,n.a)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},11151:(e,s,a)=>{a.d(s,{Z:()=>o,a:()=>i});var t=a(67294);const n={},r=t.createContext(n);function i(e){const s=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),t.createElement(r.Provider,{value:s},e.children)}}}]);