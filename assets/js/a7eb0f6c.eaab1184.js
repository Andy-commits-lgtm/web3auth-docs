"use strict";(self.webpackChunkweb3auth_docs=self.webpackChunkweb3auth_docs||[]).push([[86713],{152:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>a,toc:()=>d});var s=t(85893),r=t(11151);t(14438);const i={title:"Nodes and DKG",displayed_sidebar:"docs",description:"DKG Nodes in Wallet Management | Documentation - Web3Auth"},o=void 0,a={id:"infrastructure/nodes-and-dkg",title:"Nodes and DKG",description:"DKG Nodes in Wallet Management | Documentation - Web3Auth",source:"@site/docs/infrastructure/nodes-and-dkg.mdx",sourceDirName:"infrastructure",slug:"/infrastructure/nodes-and-dkg",permalink:"/docs/infrastructure/nodes-and-dkg",draft:!1,unlisted:!1,editUrl:"https://github.com/web3auth/web3auth-docs/edit/master/docs/infrastructure/nodes-and-dkg.mdx",tags:[],version:"current",frontMatter:{title:"Nodes and DKG",displayed_sidebar:"docs",description:"DKG Nodes in Wallet Management | Documentation - Web3Auth"},sidebar:"docs",previous:{title:"SSS Architecture",permalink:"/docs/infrastructure/sss-architecture"},next:{title:"Glossary",permalink:"/docs/infrastructure/glossary"}},h={},d=[{value:"Lifecycle",id:"lifecycle",level:2},{value:"Initialization",id:"initialization",level:3},{value:"Operation",id:"operation",level:3},{value:"Mapping user IDs to keys",id:"mapping-user-ids-to-keys",level:4},{value:"Generating distributed key shares",id:"generating-distributed-key-shares",level:4},{value:"Allowing users to retrieve their shares.",id:"allowing-users-to-retrieve-their-shares",level:4},{value:"Migration",id:"migration",level:3},{value:"Trust Assumptions",id:"trust-assumptions",level:3},{value:"Key Assignments",id:"key-assignments",level:2},{value:"Verifiers and Key Retrieval",id:"verifiers-and-key-retrieval",level:3},{value:"Front-Running Protection",id:"front-running-protection",level:2},{value:"Attack 1: Front-runner intercepts the original commitment request and sends a modified public key",id:"attack-1-front-runner-intercepts-the-original-commitment-request-and-sends-a-modified-public-key",level:3},{value:"Attack 2: Front-runner intercepts the reveal request and resends it to other nodes",id:"attack-2-front-runner-intercepts-the-reveal-request-and-resends-it-to-other-nodes",level:3}];function l(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"The Web3Auth Auth Network Nodes run a Distributed Key Generation protocol amongst themselves to assign, store and return secrets/keys to users. In\ngeneral within Auth Network, nodes manage a share retrieved via conventional OAuth flows."}),"\n",(0,s.jsx)(n.p,{children:"The architecture consists of four parts:\u200c"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Nodes in charge of Distributed Key Generation (DKG)"}),"\n",(0,s.jsx)(n.li,{children:"A smart contract in charge of the management of nodes"}),"\n",(0,s.jsx)(n.li,{children:"A private BFT network between nodes"}),"\n",(0,s.jsx)(n.li,{children:"A front-end client/SDK that interacts with nodes"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Architecture",src:t(17581).Z+"",width:"16384",height:"9832"})}),"\n",(0,s.jsx)(n.p,{children:"A smart contract is used for node discovery. Nodes are selected, operate for a fixed period, and generate a set of keys via DKG.\u200c"}),"\n",(0,s.jsx)(n.p,{children:"When a user arrives at a DApp, the client is loaded. From there, a user logs in, they provide proof that they are logged in, and the proof is verified\nby each node individually. This proof is integrated with the modern OAuth 2.0 Token Authentication flow. For new users, nodes will assign a new key\nshare from the pre-generated set of key shares, and store this assignment in an internal mapping. For returning users, nodes will look up their\ninternal mapping and return that user's corresponding key share.\u200c"}),"\n",(0,s.jsx)(n.p,{children:"The client then assembles these shares and reconstructs the users key in the front-end."}),"\n",(0,s.jsx)(n.h2,{id:"lifecycle",children:"Lifecycle"}),"\n",(0,s.jsx)(n.h3,{id:"initialization",children:"Initialization"}),"\n",(0,s.jsx)(n.p,{children:"When a Auth Network Node is started, it tries to register its connection details on an Ethereum smart contract. Once all nodes have been registered\nfor that epoch, they try to connect with each other to set up the BFT network, and start generating distributed keys. They also listen for incoming\ninformation from nodes in the previous epoch."}),"\n",(0,s.jsx)(n.h3,{id:"operation",children:"Operation"}),"\n",(0,s.jsx)(n.p,{children:"During operation, a node runs three separate parallel process:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Mapping user IDs to keys"}),"\n",(0,s.jsx)(n.li,{children:"Generating distributed key shares"}),"\n",(0,s.jsx)(n.li,{children:"Allowing users to retrieve their shares."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"mapping-user-ids-to-keys",children:"Mapping user IDs to keys"}),"\n",(0,s.jsx)(n.p,{children:"The mapping process primarily interacts with the BFT layer, which allows nodes to share state on which keys belong to which users. When a new user\nrequests for a key, the node submits a BFT transaction that modifies this state. Existing users who have logged in are compared against this shared\nstate to ensure that they retrieve the correct key share."}),"\n",(0,s.jsx)(n.h4,{id:"generating-distributed-key-shares",children:"Generating distributed key shares"}),"\n",(0,s.jsx)(n.p,{children:"The distributed key generation process primarily uses libp2p for communication between nodes, and generates a buffer of shared keys, in order to\nreduce the average response time for key assignments for new users."}),"\n",(0,s.jsx)(n.h4,{id:"allowing-users-to-retrieve-their-shares",children:"Allowing users to retrieve their shares."}),"\n",(0,s.jsx)(n.p,{children:"The share retrieval process starts when a user wishes to retrieve their keys. They individually submit their OAuth token via a commit-reveal scheme to\nthe nodes, and once this OAuth token is checked for uniqueness and validity, each node returns the user's (encrypted) key share. This does not\nrequire communication between the nodes."}),"\n",(0,s.jsx)(n.p,{children:"Assignments of keys to new users only require interaction with the mapping process, assuming that there is at least one unassigned key in the buffer.\nAs such, we are able to assign keys to accounts ahead of time, before that accounts' owner decides to login and reconstruct the key. This forms the\nbasis for our account resolver APIs."}),"\n",(0,s.jsx)(n.h3,{id:"migration",children:"Migration"}),"\n",(0,s.jsx)(n.p,{children:"When an epoch comes to an end, the current node operators agree on the next epoch, and send information about the current mapping state and the\nexisting keys to the next set of nodes in the next epoch. This is done via typical reliable broadcast methods for the mapping, and PSS (proactive\nsecret sharing) for the key shares."}),"\n",(0,s.jsx)(n.h3,{id:"trust-assumptions",children:"Trust Assumptions"}),"\n",(0,s.jsxs)(n.p,{children:["The Torus Network operates on two main threshold assumptions: a key generation threshold (>\xbc)and a key retrieval threshold (>\xbd). Generating\nkeys for new users requires more than \xbe of the nodes to be operating honestly, and reconstructing keys for existing users requires >\xbd of the nodes\nto be operating honestly. For more information, refer to the dual-threshold construction in ",(0,s.jsx)(n.a,{href:"https://eprint.iacr.org/2002/134.pdf",children:"AVSS"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"While most other secret sharing schemes use \u2154 honest majority with a >\u2153 reconstruction threshold, our preference for total system failure over key\ntheft favors the former thresholds.\u200c"}),"\n",(0,s.jsx)(n.h2,{id:"key-assignments",children:"Key Assignments"}),"\n",(0,s.jsxs)(n.p,{children:["The keys are assigned to a combination of ",(0,s.jsx)(n.code,{children:"verifier"})," (e.g., Google, Reddit, Discord) and ",(0,s.jsx)(n.code,{children:"verifier_id"})," (e.g., email, username), which is a unique\nidentifier respective to and provided by the ",(0,s.jsx)(n.code,{children:"verifier"}),".\u200c This assignment can be triggered by any node and is decided through the nodes consensus\nlayer."]}),"\n",(0,s.jsx)(n.h3,{id:"verifiers-and-key-retrieval",children:"Verifiers and Key Retrieval"}),"\n",(0,s.jsx)(n.p,{children:"The fundamental flow for Torus sign-in is as follows:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Standard login with OAuth2 (Google, Facebook, Apple, Reddit, Discord, Twitch)",src:t(84561).Z+"",width:"8640",height:"7636"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Your application gets the user to sign-in via their preferred method (OAuth / email password / passwordless / verification code)."}),"\n",(0,s.jsx)(n.li,{children:"After the user gives consent/verifies his/her email, Torus SDK will receive an ID token and assign a key to the user depending on User Verifier ID\nfrom ID Token."}),"\n",(0,s.jsx)(n.li,{children:"The key is retrieved from the Torus network and exposed to Web3 provider (DApp) to complete user sign-in request."}),"\n",(0,s.jsxs)(n.li,{children:["Torus uses this ID Token to check if the user\u2019s profile information exists in the DApp.","\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"If it does, the user will be signed in to the DApp with their preferred login."}),"\n",(0,s.jsx)(n.li,{children:"If it doesn\u2019t, the user can create a new account on the DApp with their preferred login."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In order to allow for general verifiers to be used instead of only allowing OAuth, we typically need at least two of these APIs to be implemented by\nthe external verifier:\u200c"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"an API that issues unique tokens when a user is logged in."}),"\n",(0,s.jsx)(n.li,{children:"an API that consumes these tokens and returns user information as well as when the token was issued."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The first API must be accessible from the browser (e.g. CORS-enabled, restricted headers), in order to ensure that the Torus servers are not able to\nintercept the user's token (front-running)."}),"\n",(0,s.jsx)(n.p,{children:"Typically any entity that fulfills these two APIs and provides signatures on unique ID strings and timestamp can be a verifier. This is extendable to\nseveral authentication schemes, including existing authentication standards like OAuth Token flow and OpenID Connect.\u200c"}),"\n",(0,s.jsx)(n.h2,{id:"front-running-protection",children:"Front-Running Protection"}),"\n",(0,s.jsx)(n.p,{children:"In order to prevent a rogue node, or the Torus servers, from front-running you by taking your token, impersonating your login, and thereby stealing\nyour key, we use a commitment scheme on our token similar to Bracha's Reliable Broadcast, to ensure that all nodes can be sure that a threshold number\nof other nodes are aware of the commitment, before it is finally revealed.\u200c"}),"\n",(0,s.jsx)(n.p,{children:"The general approach is as follows: we ensure that the front-end gets access to the token first, creates a commitment to the token and a temporary\npublic-private keypair, and reveals the token only if a threshold number of nodes accept this commitment. The nodes will then use this keypair to\nencrypt the shares before sending it to the user."}),"\n",(0,s.jsx)(n.p,{children:"This is done by generating a temporary public-private keypair in the front-end. The front-end calls the first API and receives an authentication\ntoken. This token is hashed, and the front-end sends the token hash and the temporary public key to each node, and each node returns a signature on\nthis message, if this is the first time they have seen this token commitment. A bundle of these signatures is the proof, and submitting the proof\ntogether with the plain (unhashed token) to each node results in the node responding with a key share that is encrypted with the temporary public\nkey."}),"\n",(0,s.jsx)(n.h3,{id:"attack-1-front-runner-intercepts-the-original-commitment-request-and-sends-a-modified-public-key",children:"Attack 1: Front-runner intercepts the original commitment request and sends a modified public key"}),"\n",(0,s.jsx)(n.p,{children:"In this case, the user will not receive a threshold number of signatures, and thus will not reveal their token. They will then be required to login\nagain and request for a new token. Since the requests to the nodes are made in a random order, eventually a threshold honest set can be reached before\na front-runner receives the commitment request."}),"\n",(0,s.jsx)(n.h3,{id:"attack-2-front-runner-intercepts-the-reveal-request-and-resends-it-to-other-nodes",children:"Attack 2: Front-runner intercepts the reveal request and resends it to other nodes"}),"\n",(0,s.jsx)(n.p,{children:"Since a public key is already associated with the token in the commitment request, nodes will only respond with encrypted shares. Even if a\nfront-runner intercepts the encrypted shares, they will be unable to decrypt it."})]})}function c(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},14438:(e,n,t)=>{t.d(n,{Z:()=>s});const s=t.p+"assets/images/key-management-f9daa363b42ea39692411c92766251cc.png"},17581:(e,n,t)=>{t.d(n,{Z:()=>s});const s=t.p+"assets/images/graph-6-final-6efc0ee0f60fa43c6913996860f1b45d.png"},84561:(e,n,t)=>{t.d(n,{Z:()=>s});const s=t.p+"assets/images/login-key-assignments-bee2e682efffdf37930e6224ae3558c9.png"},11151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>o});var s=t(67294);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);