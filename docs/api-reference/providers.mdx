---
title: Providers
hide_title: true
---

---

## EIP1193 Providers

### Getting a provider from Web3Auth.

Each adapter in web3auth exposes a provider on successful user authentication.
This provider can be use to interact with wallet or connected chain using rpc calls.
Currently web3auth supports providers for both evm and solana chains.

- If you are using `eip155` as chainNamespace while initializing `web3auth` then it will provide you with `eip1193` compatible provider as `web3auth.provider`
after user login as shown in code below.

Example:-
```ts
   import { Web3Auth } from "@web3auth/web3auth";
    import { CHAIN_NAMESPACES, CustomChainConfig, ADAPTER_EVENTS } from "@web3auth/base";

    // you can pass your own chain configs here
    // by default it will only chainId is required for supported networks such as [rinkeby, ropsten, goerli, kovan]
    const ethChainConfig: CustomChainConfig = {
        chainNamespace: CHAIN_NAMESPACES.EIP155,
        chainId: "0x3",
        rpcTarget: `https://ropsten.infura.io/v3/${YOUR_INFURA_ID}`,
        displayName: "ropsten",
        blockExplorer: "https://ropsten.etherscan.io/",
        ticker: "ETH",
        tickerName: "Ethereum",
    };
    // We are initializing with EIP155 namespace which
    // will initialize the modal with ethereum mainnet
    // by default.
    const web3auth = new Web3Auth({
        chainConfig: ethChainConfig
        clientId: "localhost-id" // get your clientId from https://developer.web3auth.io
    });
    await web3auth.initModal();
    web3auth.on(ADAPTER_EVENTS.CONNECTED, (data: CONNECTED_EVENT_DATA) => {
      console.log("Yeah!, you are successfully logged in", data);
      // On connection, you can use `web3auth.provider` as a EIP1193 provider with web3.js or ethers
      // as given in api reference below.

    });

    web3auth.connect();

```


### Getting a provider from private key.
- `@web3auth/ethereum-provider` package can be used to get a EIP1193 compatible provider from any secp512k1 private key.
  You can use this package with openlogin and customAuth sdks, to get eip1193 provider from
  logged in user's private key.

Example:

```ts
      import { EthereumPrivateKeyProvider } from "@web3auth/ethereum-provider";

      // privKey: any secp512k1 private key.
      // You can use this function with openlogin and customAuth sdks, to get eip1193 provider from
      // logged in user's private key
      async setProvider(privKey: string) {
          this.ethereumPrivateKeyProvider = new EthereumPrivateKeyProvider({
            config: {
              // pass the chain config that you want to connect with
              // all chainConfig fields are required.
              chainConfig: {
                chainId: "0x3",
                rpcTarget: `https://ropsten.infura.io/v3/${YOUR_INFURA_ID}`,
                displayName: "ropsten",
                blockExplorer: "https://ropsten.etherscan.io/",
                ticker: "ETH",
                tickerName: "Ethereum",
              },
            },
          });
          // pass user's private key here.
          // after calling setupProvider, we can use`this.ethereumPrivateKeyProvider._providerProxy`
          // as a eip1193 provider
          const provider = await this.ethereumPrivateKeyProvider.setupProvider(privKey);
      },

```

### Initializing provider


```ts
  import Web3 from 'web3';
  // you can use any of the provider from above examples to initialize with web3 js/ethers library.
  // i.e `web3auth.provider` or `this.ethereumPrivateKeyProvider._providerProxy`
  const web3 = new Web3(provider);

```

## Get Connected User account

```ts
  import Web3 from 'web3';

  // refer to `Getting a provider with web3auth login.` section above
  // to know how `web3auth.provider` is initialized after user's login
  const web3 = new Web3(web3auth.provider);

  // Get user's Ethereum public address
  const address = (await web3.eth.getAccounts())[0];

  // Get user's balance in ether
  const balance = web3.utils.fromWei(
    await web3.eth.getBalance(address), // Balance is in wei
  );
```

## Send Transaction

```ts

  import Web3 from 'web3';
  // refer to `Getting a provider with web3auth login.` section above
  // to know how `web3auth.provider` is initialized after user's login
  const web3 = new Web3(web3auth.provider);

  // Get user's Ethereum public address
  const fromAddress = (await web3.eth.getAccounts())[0];

  const destination = '0xE0cef4417a772512E6C95cEf366403839b0D6D6D';
  const amount = web3.utils.toWei(1); // Convert 1 ether to wei

  // Submit transaction to the blockchain and wait for it to be mined
  const receipt = await web3.eth.sendTransaction({
    from: fromAddress,
    to: destination,
    value: amount,
  });

```


## Sign a message

  ### Personal Sign

  ```ts
    import Web3 from 'web3';

    // refer to `Getting a provider with web3auth login.` section above
    // to know how `web3auth.provider` is initialized after user's login
    const web3 = new Web3(web3auth.provider);

    // Get user's Ethereum public address
    const fromAddress = (await web3.eth.getAccounts())[0];

    const originalMessage = 'YOUR_MESSAGE';

    const signedMessage = await web3.eth.personal.sign(originalMessage, fromAddress);
  ```


  ### Sign Typed Data V1

  ```ts
    import Web3 from 'web3';

     // refer to `Getting a provider with web3auth login.` section above
    // to know how `web3auth.provider` is initialized after user's login
    const web3 = new Web3(web3auth.provider);

    // Get user's Ethereum public address
    const fromAddress = (await web3.eth.getAccounts())[0];

    const originalMessage = [
      {
        type: 'string',
        name: 'fullName',
        value: 'John Doe',
      },
      {
        type: 'uint32',
        name: 'userId',
        value: '1234',
      },
    ];
    const params = [originalMessage, fromAddress];
    const method = 'eth_signTypedData';

    const signedMessage = await web3.currentProvider.sendAsync({
      id: 1,
      method,
      params,
      fromAddress,
    });
  ```

  ### Sign Typed Data v3

  ```ts

    import Web3 from 'web3';

    // refer to `Getting a provider with web3auth login.` section above
    // to know how `web3auth.provider` is initialized after user's login
    const web3 = new Web3(web3auth.provider);

    // Get user's Ethereum public address
    const fromAddress = (await web3.eth.getAccounts())[0];

    const originalMessage = {
      types: {
        EIP712Domain: [
          {
            name: 'name',
            type: 'string',
          },
          {
            name: 'version',
            type: 'string',
          },
          {
            name: 'verifyingContract',
            type: 'address',
          },
        ],
        Greeting: [
          {
            name: 'contents',
            type: 'string',
          },
        ],
      },
      primaryType: 'Greeting',
      domain: {
        name: 'web3auth',
        version: '1',
        verifyingContract: '0xE0cef4417a772512E6C95cEf366403839b0D6D6D',
      },
      message: {
        contents: 'Hello, from web3auth!',
      },
    };
    const params = [fromAddress, originalMessage];
    const method = 'eth_signTypedData_v3';

    const signedMessage = await web3.currentProvider.sendAsync({
      id: 1,
      method,
      params,
      fromAddress,
    });

  ```


  ### Sign Typed Data v4

  ```ts

    /*
    Sign Typed Data v4 adds support for
    arrays and recursive data types.

    Otherwise, it works the same as Sign Typed Data v3.
  */

    import Web3 from 'web3';

    // refer to `Getting a provider with web3auth login.` section above
    // to know how `web3auth.provider` is initialized after user's login
    const web3 = new Web3(web3auth.provider);

    // Get user's Ethereum public address
    const fromAddress = (await web3.eth.getAccounts())[0];

    const originalMessage = {
      types: {
        EIP712Domain: [
          {
            name: 'name',
            type: 'string',
          },
          {
            name: 'version',
            type: 'string',
          },
          {
            name: 'verifyingContract',
            type: 'address',
          },
        ],
        Greeting: [
          {
            name: 'contents',
            type: 'string',
          },
        ],
      },
      primaryType: 'Greeting',
      domain: {
        name: 'web3auth',
        version: '1',
        verifyingContract: '0xE0cef4417a772512E6C95cEf366403839b0D6D6D',
      },
      message: {
        contents: 'Hello, from web3auth!',
      },
    };
    const params = [fromAddress, originalMessage];
    const method = 'eth_signTypedData_v4';

    const signedMessage = await web3.currentProvider.sendAsync({
      id: 1,
      method,
      params,
      fromAddress,
    });
```


- You can refer to other read only calls available for this provider [here](https://eth.wiki/json-rpc/API#json-rpc-methods)

---------------------
## Solana Providers
- if you are using `solana` as chainNamespace while initializing `web3auth` then it it will provide you a provider with
some custom rpc calls which are specific to `web3auth`.

#### Various rpc methods available on solana provider are:-

- `solana_requestAccounts`: This method is used fetch the address of connected account.
    - Example
    ```ts
    import { SafeEventEmitterProvider } from "@web3auth/base";
     async requestAccounts(): Promise<string[]> {
    const accounts = await this.provider.request<string[]>({
      method: "solana_requestAccounts",
      params: {},
    });
    return accounts;
  }
    ```

- `signTransaction`: This method is used to sign a single serialized transaction and it returns a signed `Transaction` object.

    - Example:
    ```ts
     import type { Transaction } from "@solana/web3.js";
    import { SafeEventEmitterProvider } from "@web3auth/base";
     async signTransaction(transaction: Transaction): Promise<Transaction> {
    const signedTransaction = (await this.provider.request({
      method: "signTransaction",
      params: {
        message: bs58.encode(transaction.serializeMessage()),
      },
    })) as Transaction;
    return signedTransaction;
  }

    ```

- `signAllTransactions`:-  This method is used to sign a list of serialized transactions and it returns back list of signed of `Transaction` objects.

    - Example:
    ```ts
    import type { Transaction } from "@solana/web3.js";
    import { SafeEventEmitterProvider } from "@web3auth/base";

    async signAllTransactions(provider: SafeEventEmitterProvider ,transactions: string[]): Promise<Transaction[]> {
        const signedTransaction = (await provider.request({
          method: "signAllTransactions",
          params: {
            message: transactions,
          },
        })) as Transaction[];
        return signedTransaction;
      }

    ```

- `signAndSendTransaction`: This function is used to sign and broadcast the transaction on chain. It returns the signature of broadcasted transaction.

    - Example:
    ```ts
     import type { Transaction } from "@solana/web3.js";
    import { SafeEventEmitterProvider } from "@web3auth/base";
    async signAndSendTransaction(transaction: Transaction): Promise<{ signature: string }> {
    const { signature } = await this.provider.request<{ signature: string }>({
      method: "signAndSendTransaction",
      params: {
        message: bs58.encode(transaction.serializeMessage()),
      },
    });
    return { signature };
  }

    ```

- `signMessage`: This method is used sign any message from connected wallet.
    - Example:-
    ```ts
    import { SafeEventEmitterProvider } from "@web3auth/base";

      async signMessage(provider: SafeEventEmitterProvider ,data: Uint8Array): Promise<Uint8Array> {
        const response = await provider.request<Uint8Array>({
          method: "signMessage",
          params: {
            message: data,
          },
        });
        return response as Uint8Array;
      }

    ```
- `solanaPrivateKey`: This method is used to fetch the private key of logged in user. It is only available for `in-app` adapters like `customAuth` or `openlogin`.

    - Example:-
    ```ts

        const privateKey = await provider.request<string>({
          method: "solanaPrivateKey",
          params: {},
        });

    ```

#### Other default solana chain rpc methods:
- All the rpc methods which are available by default on solana blockchain are also available on solana provider except for the case of `phantom` adapter they are not available.

- You can refer to standard rpc calls for solana [here](https://docs.solana.com/developing/clients/jsonrpc-api)
