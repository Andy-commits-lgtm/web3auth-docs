---
title: "Usage of MPC Core Kit Web SDK"
sidebar_label: "Usage"
displayed_sidebar: sdk
description: "Web3Auth MPC Core Kit Web SDK - Usage | Documentation - Web3Auth"
---

Once you've installed and successfully initialized `Web3AuthMPCCoreKit`, you can use it to authenticate your users. Further, you can use the native
provider given by Web3Auth to sign transactions and interact with the blockchain.

Natively, the instance of `Web3AuthMPCCoreKit` (referred to as `coreKitInstance` in our examples) returns the following functions:

Authentication Functions:

- `loginWithOAuth()` - Logs in the user in OAuth Intrisic Flow.
- `loginWithJWT()` - Logs in the user with a JWT based ID Token.
- `logout()` - Logs out the User.
- `handleRedirectResult()` - Handles the redirect result while logging in the User, while in redirect mode in Intrinsic Flow.

Handling Factors:

- `inputFactorKey()` - Inputs the Factor Key to recover the User's account.
- `getCurrentFactorKey()` - Returns the current Factor Key of the User's account, present in the state of the SDK.
- `createFactor()` - Creates a new Factor for the User's account.
- `deleteFactor()` - Deletes a Factor from the User's account.

User Functions:

- `getUserInfo()` - Returns the User's information received from the ID Token.
- `getKeyDetails()` - Returns the User's Key Details.
- `commitChanges()` - Commits the changes made to the User's account while in manual sync mode.

Import/ Export Keys:

- `importTssKey()` - Imports a TSS Key to the User's account. Useful to import an already existing account into the MPC Archiecture.
- `_UNSAFE_exportTssKey()` - Exports the TSS Key of the User's account. Not recommended for general usage, however, can be used in cases where users
  ask for their private key.

Additional Helper Functions:

- Web Storage
  - `storeWebBrowserFactor()` - Stores a Factor in the Web Local/ Session Storage.
  - `getWebBrowserFactor()` - Returns the Factor from the Web Local/ Session Storage.
- Security Questions
  - `setSecurityQuestion()` - Sets the Security Question Factor for the User's account.
  - `changeSecurityQuestion()` - Changes the Security Question for the User's account.
  - `deleteSecurityQuestion()` - Deletes the Security Question for the User's account.
  - `recoverSecurityQuestionFactor()` - Recovers the Security Question Factor for the User's account using the given password.
  - `getQuestion()` - Returns the Security Question for the User's account.
- Conversion from Mnemonic
  - `mnemonicToKey()` - Converts a Mnemonic to a BN.

## Log In with OAuth Intrinsic Flow

#### `loginWithOauth(loginParams: OauthLoginParams): Promise<void>;`

| Variable      | Type     | Description      | Mandatory |
| ------------- | -------- | ---------------- | --------- |
| `loginParams` | `object` | Login Parameters | Yes       |

### `OauthLoginParams`

Contains the parameters required to login a user. This is a mandatory field to be passed in the `connect()` function.

<Tabs
  defaultValue="table"
  values={[
    { label: "Table", value: "table" },
    { label: "Type", value: "type" },
  ]}
>

<TabItem value="table">

| Parameter                      | Type                   | Description                                                                                                                             | Mandatory |
| ------------------------------ | ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------- | --------- |
| `subVerifierDetails`           | `SubVerifierDetails`   | Details of the verifier the app needs to connect to. This is named a "sub verifier" to accommodate for aggregate verifiers as well.     | Yes       |
| `aggregateVerifierIdentifier?` | `string`               | Identifier/ Name of the aggregate verifier you've made on the Web3Auth Dashboard. Not needed if you're connecting to a single verifier. | No        |
| `subVerifierDetailsArray?`     | `SubVerifierDetails[]` | Array of the details of verifiers the app needs to connect to.                                                                          | No        |

</TabItem>

<TabItem value="type">

```javascript
export type OauthLoginParams = SubVerifierDetailsParams | AggregateVerifierLoginParams;

export interface SubVerifierDetailsParams extends BaseLoginParams {
  subVerifierDetails: SubVerifierDetails;
}

export interface AggregateVerifierLoginParams extends BaseLoginParams {
  aggregateVerifierIdentifier?: string;
  aggregateVerifierType?: AGGREGATE_VERIFIER_TYPE;
  subVerifierDetailsArray?: SubVerifierDetails[];
}

export interface BaseLoginParams {
  // offset in seconds
  serverTimeOffset?: number;
}

export type AGGREGATE_VERIFIER_TYPE = (typeof AGGREGATE_VERIFIER)[keyof typeof AGGREGATE_VERIFIER];

export declare const AGGREGATE_VERIFIER: {
    readonly SINGLE_VERIFIER_ID: "single_id_verifier";
};
```

</TabItem>

</Tabs>

#### `SubVerifierDetails`

Contains the details of verifier the app needs to connect to. Use this in case of a single verifier.

<Tabs
  defaultValue="table"
  values={[
    { label: "Table", value: "table" },
    { label: "Interface", value: "interface" },
  ]}
>

<TabItem value="table">

| Parameter   | Type          | Description                                                                                                                                                                                                                                                         | Mandatory |
| ----------- | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------- |
| typeOfLogin | `TypeOfLogin` | Type of login of this verifier, this value will affect the login flow that is adapted. For example, if you choose `google`, a Google sign-in flow will be used. If you choose `jwt`, you should be providing your own JWT token, no sign-in flow will be presented. | Yes       |
| `verifier`  | `string`      | Name/ Identifier of the verifier/ sub verifier in case of aggregate verifiers, you'd like your app to connect to.                                                                                                                                                   | Yes       |
| `clientId`  | `string`      | Client Id given by the auth provider. Pass a random string in case you're connecting to a JWT based setup.                                                                                                                                                          | Yes       |

</TabItem>

<TabItem value="interface">

```javascript
export interface SubVerifierDetails {
    typeOfLogin: LOGIN_TYPE;
    verifier: string;
    clientId: string;
    jwtParams?: Auth0ClientOptions;
    hash?: string;
    queryParameters?: TorusGenericObject;
    customState?: TorusGenericObject;
}

export type LOGIN_TYPE = (typeof LOGIN)[keyof typeof LOGIN];

export declare const LOGIN: {
    readonly GOOGLE: "google";
    readonly FACEBOOK: "facebook";
    readonly REDDIT: "reddit";
    readonly DISCORD: "discord";
    readonly TWITCH: "twitch";
    readonly APPLE: "apple";
    readonly GITHUB: "github";
    readonly LINKEDIN: "linkedin";
    readonly TWITTER: "twitter";
    readonly WEIBO: "weibo";
    readonly LINE: "line";
    readonly EMAIL_PASSWORD: "email_password";
    readonly PASSWORDLESS: "passwordless";
    readonly JWT: "jwt";
    readonly WEBAUTHN: "webauthn";
};
```

</TabItem>

</Tabs>

#### `AggregateVerifierLoginParams`

Contains the details of an aggregate verifier the app needs to connect to. Use this in case of an aggregate verifier.

<Tabs
  defaultValue="table"
  values={[
    { label: "Table", value: "table" },
    { label: "Interface", value: "interface" },
  ]}
>

<TabItem value="table">

| Parameter                     | Type                      | Description                                                                                                         | Mandatory |
| ----------------------------- | ------------------------- | ------------------------------------------------------------------------------------------------------------------- | --------- |
| `aggregateVerifierIdentifier` | `string`                  | The name of your aggregate verifier                                                                                 | Yes       |
| `aggregateVerifierType`       | `AGGREGATE_VERIFIER_TYPE` | What kind of aggregation is needed for your aggregate verifier. Use `"single_id_verifier"` by default in most cases | Yes       |
| `subVerifierDetailsArray`     | `SubVerifierDetails[]`    | An array containing the details of your sub verifiers.                                                              | Yes       |

</TabItem>

<TabItem value="interface">

```javascript
export interface AggregateVerifierLoginParams extends BaseLoginParams {
  aggregateVerifierIdentifier?: string;
  aggregateVerifierType?: AGGREGATE_VERIFIER_TYPE;
  subVerifierDetailsArray?: SubVerifierDetails[];
}
export type AGGREGATE_VERIFIER_TYPE = (typeof AGGREGATE_VERIFIER)[keyof typeof AGGREGATE_VERIFIER];
```

</TabItem>

</Tabs>

### Usage

### General Verifier

```tsx
import { Web3AuthMPCCoreKit, SubVerifierDetailsParams } from "@web3auth/mpc-core-kit";

const verifierConfig = {
  subVerifierDetails: {
    typeOfLogin: "google",
    verifier: "w3a-google-demo",
    clientId: "519228911939-cri01h55lsjbsia1k7ll6qpalrus75ps.apps.googleusercontent.com",
  },
} as SubVerifierDetailsParams;

await coreKitInstance.loginWithOauth(verifierConfig);
```

### Aggregate Verifier

```tsx
import { Web3AuthMPCCoreKit, AggregateVerifierLoginParams } from "@web3auth/mpc-core-kit";

const verifierConfig = {
  aggregateVerifierIdentifier: "aggregate-sapphire",
  aggregateVerifierType: "single_id_verifier",
  subVerifierDetailsArray: [
    {
      typeOfLogin: "google",
      verifier: "w3a-google",
      clientId: "774338308167-q463s7kpvja16l4l0kko3nb925ikds2p.apps.googleusercontent.com",
    },
  ],
} as AggregateVerifierLoginParams;

await coreKitInstance.loginWithOauth(verifierConfig);
```

## Handle Redirect Result

#### `handleRedirectResult(): Promise<SafeEventEmitterProvider | null>;`

While using the redirect mode, you need to handle the redirect result in your application. This can be done by calling the `handleRedirectResult()`
method of the `web3auth` instance, within the constructor of the component where you want to handle the redirect result.

If your URL anchor contains `#state`, then the `handleRedirectResult()` method should be called, since that is where the redirect result, containing
the `idToken` is returned from the login provider.

#### Example

```javascript
useEffect(() => {
  const submitRedirectResult = async () => {
    try {
      const provider = await coreKitInstance?.handleRedirectResult();
      if (provider) setProvider(provider);
    } catch (error) {
      if ((error as Error).message === "required more shares") {
        uiConsole("first triggered", coreKitInstance);
        recoverAccount();
      }
    }
  }
  if (coreKitInstance && window.location.hash.includes("#state")) {
    submitRedirectResult();
  }
}, [coreKitInstance]);
```

:::note

For the popup flow, the service worker is needed to handle it properly. Please have a look at the
[installation page](/sdk/core-kit/mpc-core-kit/install) to know how to set up the service worker for your application.

:::

## Logging out the User

#### `logout(): Promise<void>;`

Disconnect the user's connected wallet/ provider and log them out of the Web3Auth MPC Core Kit SDK.

#### Example

```tsx
await coreKitInstance.logout();
```

## Export Backup Share

#### `exportBackupShare(): Promise<string>;`

Returns the Backup Mnemonic Share, which can be used to recover the User's account on a different device than they have logged in previously.

#### Example

```tsx
await coreKitInstance.exportBackupShare();
```

## Input Backup Share

#### `inputBackupShare(shareMnemonic: string): Promise<void>;`

Inputs the Backup Mnemonic Share to recover the User's account.

#### Example

```tsx
await coreKitInstance.inputBackupShare(seedPhrase);
```

## Add Security Question Share

#### `addSecurityQuestionShare(question: string, password: string): Promise<void>;`

Creates a security question share for your to easily recover user's account. Since this share can take any question and password, you can innovatively
use this to create any flow for your users to recover their account. From a general password login to using mobile OTP based login and associating a
certain parameter on successful authentication, you can use this share to create any flow you want.

#### Example

```tsx
await coreKitInstance.addSecurityQuestionShare("What is your password?", password);
```

## Recover Security Question Share

#### `recoverSecurityQuestionShare(question: string, password: string): Promise<void>;`

Recover the User's account using the Security Question Share.

#### Example

```tsx
await coreKitInstance.recoverSecurityQuestionShare("What is your password?", password);
```

## Change Security Question Share

#### `changeSecurityQuestionShare(question: string, password: string): Promise<void>;`

Changes the Security Question Share of the User's account. This helps you change the password if the user has lost it somehow. However, this function
can only be used if the user has already logged in within the application while meeting the minimum share threshold.

#### Example

```tsx
await coreKitInstance.changeSecurityQuestionShare("What is your password?", password);
```

## Delete Security Question Share

#### `deleteSecurityQuestionShare(question: string): Promise<void>;`

Deletes the Security Question Share of the User's account. This function can only be used if the user has already logged in within the application
while meeting the minimum share threshold.

#### Example

```tsx
await coreKitInstance.deleteSecurityQuestionShare("What is your password?");
```

## Get User Info

#### `getUserInfo(): UserInfo;`

Returns the User's information received from the ID Token.

#### Returns

This function returns the following parameters in the form of an object:

```tsx
type UserInfo = {
  email: string;
  name: string;
  profileImage: string;
  aggregateVerifier?: string;
  verifier: string;
  verifierId: string;
  typeOfLogin: LOGIN_TYPE;
  ref?: string;
  registerOnly?: boolean;
  extraVerifierParams?: WebAuthnExtraParams;
  accessToken: string;
  idToken?: string;
  ref?: string;
  extraParams?: string;
  extraParamsPassed?: string;
  state: TorusGenericObject;
};
```

#### Example

```tsx
await coreKitInstance.getUserInfo();
```

## Get Key Details

#### `getKeyDetails(): KeyDetails;`

Returns the details of how the user's key is managed by the MPC Core Kit.

#### Returns

This function returns the following parameters in the form of an object:

```tsx
type KeyDetails = {
  pubKey: Point;
  requiredShares: number;
  threshold: number;
  totalShares: number;
  shareDescriptions: ShareDescriptionMap;
};
```

#### Example

```tsx
await coreKitInstance.getKeyDetails();
```

## Commit Changes

#### `commitChanges(): Promise<void>;`

Sync the local changes made to the User's account with the web3auth metadata server. This function is only to be used while in manual sync mode.

#### Example

```tsx
await coreKitInstance.commitChanges();
```

## Reset Account (CRITICAL)

#### `CRITICAL_resetAccount(): Promise<void>;`

Can be used to reset user's account in case of emergencies, when the user is unable to recover their account. This deletes all the history of the
previous key and the funds/ assets associated with it.

#### Example

```tsx
await coreKitInstance.CRITICAL_resetAccount();
```
