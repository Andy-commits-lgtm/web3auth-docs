---
title: "Authentication in MPC Core Kit Web SDK"
sidebar_label: "Authentication"
displayed_sidebar: sdk
description: "Web3Auth MPC Core Kit Web SDK - Authentication | Documentation - Web3Auth"
---

There are two ways to login your users, depending on the type of authentication method you've chosen. If you are looking for an Intrinsic
Authentication Flow in your application (like Auth0 SPA Flow), you can use the `loginWithOAuth()` function. If you are looking to pass a JWT based Id
Token to the SDK from in your application (like Auth0 RWA Flow), you can use the `loginWithJWT()` function.

As a prerequisite, before triggering the login function, you need to create a verifier for your login method on the [Web3Auth Dashboard](https://dashboard.web3auth.io).

## Creating a Verifier

Since this a Core Kit SDK, it does not provide any default authentication methods. You need to create a custom verifier in order to use this SDK. This
means that you need to authenticate users with your own custom authentication service. For example, while authenticating with Google, you have to use
your own Google Client ID and Dashboard to authenticate users directly, or use aggregate services like Auth0, Firebase, AWS Cognito etc. Additionally,
you can make your own JWT token authentication system and pass over the ID Token to the Web3Auth to generate a private key for them.

For enabling this, you need [Create a Verifier](/auth-provider-setup/verifiers) from the **Custom Auth** section of the
[Web3Auth Developer Dashboard](https://dashboard.web3auth.io) with your desired configuration.

:::tip

If you want to know more about setting up a verifier and how to use it, please refer to the
[Custom Authentication Documentation](/pnp/features/custom-authentication).

:::

:::caution

Core Kit SDK only supports Sapphire Mainnet and Devnet networks. The other networks don't support MPC functionalities.

:::

## Log In with OAuth Intrinsic Flow

#### `loginWithOauth(loginParams: OauthLoginParams): Promise<void>;`

| Variable      | Type     | Description      | Mandatory |
| ------------- | -------- | ---------------- | --------- |
| `loginParams` | `object` | Login Parameters | Yes       |

### `OauthLoginParams`

Contains the parameters required to login a user. This is a mandatory field to be passed in the `connect()` function.

<Tabs
  defaultValue="table"
  values={[
    { label: "Table", value: "table" },
    { label: "Type", value: "type" },
  ]}
>

<TabItem value="table">

| Parameter                      | Type                   | Description                                                                                                                             | Mandatory |
| ------------------------------ | ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------- | --------- |
| `subVerifierDetails`           | `SubVerifierDetails`   | Details of the verifier the app needs to connect to. This is named a "sub verifier" to accommodate for aggregate verifiers as well.     | Yes       |
| `aggregateVerifierIdentifier?` | `string`               | Identifier/ Name of the aggregate verifier you've made on the Web3Auth Dashboard. Not needed if you're connecting to a single verifier. | No        |
| `subVerifierDetailsArray?`     | `SubVerifierDetails[]` | Array of the details of verifiers the app needs to connect to.                                                                          | No        |

</TabItem>

<TabItem value="type">

```javascript
export type OauthLoginParams = SubVerifierDetailsParams | AggregateVerifierLoginParams;

export interface SubVerifierDetailsParams extends BaseLoginParams {
  subVerifierDetails: SubVerifierDetails;
}

export interface AggregateVerifierLoginParams extends BaseLoginParams {
  aggregateVerifierIdentifier?: string;
  aggregateVerifierType?: AGGREGATE_VERIFIER_TYPE;
  subVerifierDetailsArray?: SubVerifierDetails[];
}

export interface BaseLoginParams {
  // offset in seconds
  serverTimeOffset?: number;
}

export type AGGREGATE_VERIFIER_TYPE = (typeof AGGREGATE_VERIFIER)[keyof typeof AGGREGATE_VERIFIER];

export declare const AGGREGATE_VERIFIER: {
    readonly SINGLE_VERIFIER_ID: "single_id_verifier";
};
```

</TabItem>

</Tabs>

#### `SubVerifierDetails`

Contains the details of verifier the app needs to connect to. Use this in case of a single verifier.

<Tabs
  defaultValue="table"
  values={[
    { label: "Table", value: "table" },
    { label: "Interface", value: "interface" },
  ]}
>

<TabItem value="table">

| Parameter   | Type          | Description                                                                                                                                                                                                                                                         | Mandatory |
| ----------- | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------- |
| typeOfLogin | `TypeOfLogin` | Type of login of this verifier, this value will affect the login flow that is adapted. For example, if you choose `google`, a Google sign-in flow will be used. If you choose `jwt`, you should be providing your own JWT token, no sign-in flow will be presented. | Yes       |
| `verifier`  | `string`      | Name/ Identifier of the verifier/ sub verifier in case of aggregate verifiers, you'd like your app to connect to.                                                                                                                                                   | Yes       |
| `clientId`  | `string`      | Client Id given by the auth provider. Pass a random string in case you're connecting to a JWT based setup.                                                                                                                                                          | Yes       |

</TabItem>

<TabItem value="interface">

```javascript
export interface SubVerifierDetails {
    typeOfLogin: LOGIN_TYPE;
    verifier: string;
    clientId: string;
    jwtParams?: Auth0ClientOptions;
    hash?: string;
    queryParameters?: TorusGenericObject;
    customState?: TorusGenericObject;
}

export type LOGIN_TYPE = (typeof LOGIN)[keyof typeof LOGIN];

export declare const LOGIN: {
    readonly GOOGLE: "google";
    readonly FACEBOOK: "facebook";
    readonly REDDIT: "reddit";
    readonly DISCORD: "discord";
    readonly TWITCH: "twitch";
    readonly APPLE: "apple";
    readonly GITHUB: "github";
    readonly LINKEDIN: "linkedin";
    readonly TWITTER: "twitter";
    readonly WEIBO: "weibo";
    readonly LINE: "line";
    readonly EMAIL_PASSWORD: "email_password";
    readonly PASSWORDLESS: "passwordless";
    readonly JWT: "jwt";
    readonly WEBAUTHN: "webauthn";
};
```

</TabItem>

</Tabs>

#### `AggregateVerifierLoginParams`

Contains the details of an aggregate verifier the app needs to connect to. Use this in case of an aggregate verifier.

<Tabs
  defaultValue="table"
  values={[
    { label: "Table", value: "table" },
    { label: "Interface", value: "interface" },
  ]}
>

<TabItem value="table">

| Parameter                     | Type                      | Description                                                                                                         | Mandatory |
| ----------------------------- | ------------------------- | ------------------------------------------------------------------------------------------------------------------- | --------- |
| `aggregateVerifierIdentifier` | `string`                  | The name of your aggregate verifier                                                                                 | Yes       |
| `aggregateVerifierType`       | `AGGREGATE_VERIFIER_TYPE` | What kind of aggregation is needed for your aggregate verifier. Use `"single_id_verifier"` by default in most cases | Yes       |
| `subVerifierDetailsArray`     | `SubVerifierDetails[]`    | An array containing the details of your sub verifiers.                                                              | Yes       |

</TabItem>

<TabItem value="interface">

```javascript
export interface AggregateVerifierLoginParams extends BaseLoginParams {
  aggregateVerifierIdentifier?: string;
  aggregateVerifierType?: AGGREGATE_VERIFIER_TYPE;
  subVerifierDetailsArray?: SubVerifierDetails[];
}
export type AGGREGATE_VERIFIER_TYPE = (typeof AGGREGATE_VERIFIER)[keyof typeof AGGREGATE_VERIFIER];
```

</TabItem>

</Tabs>

### Usage

### General Verifier

```tsx
import { Web3AuthMPCCoreKit, SubVerifierDetailsParams } from "@web3auth/mpc-core-kit";

const verifierConfig = {
  subVerifierDetails: {
    typeOfLogin: "google",
    verifier: "w3a-google-demo",
    clientId: "519228911939-cri01h55lsjbsia1k7ll6qpalrus75ps.apps.googleusercontent.com",
  },
} as SubVerifierDetailsParams;

await coreKitInstance.loginWithOauth(verifierConfig);
```

### Aggregate Verifier

```tsx
import { Web3AuthMPCCoreKit, AggregateVerifierLoginParams } from "@web3auth/mpc-core-kit";

const verifierConfig = {
  aggregateVerifierIdentifier: "aggregate-sapphire",
  aggregateVerifierType: "single_id_verifier",
  subVerifierDetailsArray: [
    {
      typeOfLogin: "google",
      verifier: "w3a-google",
      clientId: "774338308167-q463s7kpvja16l4l0kko3nb925ikds2p.apps.googleusercontent.com",
    },
  ],
} as AggregateVerifierLoginParams;

await coreKitInstance.loginWithOauth(verifierConfig);
```

## Handle Redirect Result

#### `handleRedirectResult(): Promise<SafeEventEmitterProvider | null>;`

While using the redirect mode, you need to handle the redirect result in your application. This can be done by calling the `handleRedirectResult()`
method of the `web3auth` instance, within the constructor of the component where you want to handle the redirect result.

If your URL anchor contains `#state`, then the `handleRedirectResult()` method should be called, since that is where the redirect result, containing
the `idToken` is returned from the login provider.

#### Example

```javascript
useEffect(() => {
  const submitRedirectResult = async () => {
    try {
      const provider = await coreKitInstance?.handleRedirectResult();
      if (provider) setProvider(provider);
    } catch (error) {
      if ((error as Error).message === "required more shares") {
        uiConsole("first triggered", coreKitInstance);
        recoverAccount();
      }
    }
  }
  if (coreKitInstance && window.location.hash.includes("#state")) {
    submitRedirectResult();
  }
}, [coreKitInstance]);
```

:::note

For the popup flow, the service worker is needed to handle it properly. Please have a look at the [installation page](./install) to know how to set up
the service worker for your application.

:::
