---
title: Account Abstraction Provider
sidebar_label: Account Abstraction Provider
description: "@web3auth/no-modal Native Account Abstraction | Documentation - Web3Auth"
---

import TabItem from "@theme/TabItem";
import Tabs from "@theme/Tabs";

import AccountAbstractionDescription from "@site/src/common/sdk/pnp/web/_account-abstraction-description.mdx";
import AccountAbstractionProviderInstallation from "@site/src/common/sdk/pnp/web/_aa-provider-installation.mdx";
import ConfigureSmartAccountProvider from "@site/src/common/sdk/pnp/web/_smart-account-provider-configuration.mdx";
import ConfigureBundler from "@site/src/common/sdk/pnp/web/_bundler-configuration.mdx";
import ConfigureSponsoredPaymaster from "@site/src/common/sdk/pnp/web/_sponsored-paymaster-configuration.mdx";
import ConfigureERC20Paymaster from "@site/src/common/sdk/pnp/web/_erc20-paymaster-configuration.mdx";
import AANoModalSetup from "@site/src/common/sdk/pnp/web/_aa-no-modal-setup.mdx";
import AAModalSetup from "@site/src/common/sdk/pnp/web/_aa-modal-setup.mdx";
import ConfigureSigners from "@site/src/common/sdk/pnp/web/_configure-aa-signers.mdx";
import SmartAccountAddress from "@site/src/common/sdk/pnp/web/_aa-address.mdx";
import SmartAccountSendTransaction from "@site/src/common/sdk/pnp/web/_aa-send-transaction.mdx";

import GrowthPlanNote from "@site/src/common/docs/_growth_plan_note.mdx";

## Installation

<AccountAbstractionProviderInstallation />

## Configure

When instantiating the Account Abstraction Provider, you can pass configuration objects to the
constructor. These configuration options allow you to select the desired Account Abstraction (AA)
provider, as well as configure the bundler and paymaster, giving you flexibility and control over
the provider.

```tsx
import {
  AccountAbstractionProvider,
  SafeSmartAccount,
} from "@web3auth/account-abstraction-provider";

const chainConfig = {
  chainNamespace: CHAIN_NAMESPACES.EIP155,
  chainId: "0xaa36a7",
  rpcTarget: "https://rpc.ankr.com/eth_sepolia",
  displayName: "Ethereum Sepolia Testnet",
  blockExplorerUrl: "https://sepolia.etherscan.io",
  ticker: "ETH",
  tickerName: "Ethereum",
  logo: "https://cryptologos.cc/logos/ethereum-eth-logo.png",
};

// focus-start
const accountAbstractionProvider = new AccountAbstractionProvider({
  config: {
    chainConfig,
    bundlerConfig: {
      // Get the pimlico API Key from dashboard.pimlico.io
      url: `https://api.pimlico.io/v2/11155111/rpc?apikey=${pimlicoAPIKey}`,
    },
    smartAccountInit: new SafeSmartAccount(),
  },
});
// focus-end
```

Please note this is the important step for setting the Web3Auth account abstraction provider.

- [Configure Smart Account provider](#configure-smart-account-provider)
- [Configure Bundler](configure-bundler)
- [Configure Sponsored Paymaster](#sponsored-paymaster)
- [Configure ERC-20 Paymaster](#erc20-paymaster)

## Configure Smart Account Provider

<ConfigureSmartAccountProvider />

## Configure Bundler

<ConfigureBundler />

## Configure Paymaster

You can configure the paymaster of your choice to sponsor gas fees for your users, along with the
paymaster context. The paymaster context lets you set additional parameters, such as choosing the
token for ERC-20 paymasters, defining gas policies, and more.

### Sponsored Paymaster

<ConfigureSponsoredPaymaster />

### ERC-20 Paymaster

<ConfigureERC20Paymaster />

## Set up

Once you have configured your AccountAbstractionProvider, you can now plug it in your Web3Auth No
Modal instance. If you are also using the external wallets, you can define whether you want to use
the AccountAbstractionProvider, or EthereumPrivateKeyProvider by setting the
`useAAWithExternalWallet` in `IWeb3AuthCoreOptions`.

### Configure Web3Auth Instance

Once, you have set up the signer, you can use it to retreive the user's smart account address.

<Tabs
  defaultValue="modal"
  values={[
    { label: "PnP Modal SDK", value: "modal" },
    { label: "PnP No Modal SDK", value: "no-modal" },
  ]}
>

<TabItem value="modal">

<AAModalSetup />

</TabItem>

<TabItem value="no-modal">

<AANoModalSetup />

</TabItem>
</Tabs>

### Configure Signer

<ConfigureSigners />

## Usage

### Smart Account Address

<SmartAccountAddress />

### Send Transaction

<SmartAccountSendTransaction />

### Sign transaction

You can choose to sign a transaction without sending it. If it's the user's first transaction, the
calldata generated for the `UserOperation` will also include the necessary data to deploy a new
smart account for the user.

<Tabs
  defaultValue="viem"
  values={[
    { label: "Viem", value: "viem" },
    { label: "Ethers", value: "ethers" },
    { label: "Web3", value: "web3" },
  ]}
>

<TabItem value="web3">

```tsx
// Convert 1 ether to WEI format
const amount = web3.utils.toWei(1);

const signature = await web3.eth.signTransaction({
  from: "YOUR_ACCOUNT_ADDRESS",
  to: "DESTINATION_ADDRESS",
  value: amount,
});
```

</TabItem>
<TabItem value="ethers">

```tsx
// Convert 1 ether to WEI format
const amount = parseEther("1");

const signature = await signer.signTransaction({
  to: "DESTINATION_ADDRESS",
  value: amount,
});
```

</TabItem>
<TabItem value="viem">

```tsx
// Convert 1 ether to WEI format
const amount = parseEther("1");
const addresses = await walletClient.getAddresses();

const request = await walletClient.prepareTransactionRequest({
  account: addresses[0],
  to: "DESTINATION_ADDRESS",
  value: amount,
});

const signature = await walletClient.signTransaction(request as any);
```

</TabItem>
</Tabs>

### Sign Message

You can also sign messages using a smart account, though the signature and verification process
differs from EOA wallets. Smart accounts follow the EIP 1271 standard for verification, using the
`isValidSignature` method of the smart contract wallet, instead of the `ecrecover` function used by
EOAs.

[Learn more about EIP 1271](https://eips.ethereum.org/EIPS/eip-1271).

<Tabs
  defaultValue="viem"
  values={[
    { label: "Viem", value: "viem" },
    { label: "Ethers", value: "ethers" },
    { label: "Web3", value: "web3" },
  ]}
>

<TabItem value="web3">

```tsx
const addresses = await web3.eth.getAccounts();

const originalMessage = "YOUR_MESSAGE";

const signedMessage = await web3.eth.personal.sign(originalMessage, addresses[0]);
```

</TabItem>
<TabItem value="ethers">

```tsx
const originalMessage = "YOUR_MESSAGE";

// Sign the message
const signedMessage = await signer.signMessage(originalMessage);
```

</TabItem>
<TabItem value="viem">

```tsx
const originalMessage = "YOUR_MESSAGE";

const addresses = await walletClient.getAddresses();

const signedMessage = await walletClient.signMessage({
  account: address[0],
  message: originalMessage,
});
```

</TabItem>
</Tabs>

### Send Batch Transaction

One of the most exciting features of Smart Accounts is the ability to perform batch transactions.
Currently, if a user wants to swap Token A for Token B, they must first approve Token A and then
complete the swap. With the batch transaction functionality of Smart Accounts, both steps can be
combined into a single operation.

Performing a batch transaction differs slightly from the normal flow. To execute a batch
transaction, you'll need to use the `BundlerClient` generated by the `AccountAbstractionProvider`.
The Web3Auth instance provider can't be used for this, as it's a proxy provider designed to ensure
compatibility with your preferred signer package for basic operations.

The `BundlerClient.sendUserOperation` returns the UserOperation hash instead of transaction hash.
UserOperation hash is just keccak256 hash of the entire user operation. To retreive the tranaction
details, we need to use `waitForUserOperationReceipt`. The function will wait for the UserOperation
to be included in a block, and will return a full UserOperation, with the addition of entryPoint,
blockNumber, blockHash and transactionHash.

```ts
// Use the same accountAbstractionProvider we created earlier.
const bundlerClient = accountAbstractionProvider.bundlerClient!;
const smartAccount = accountAbstractionProvider.smartAccount!;

const amount = ethers.parseEther("0.00001");

const userOperationHash = await bundlerClient.sendUserOperation({
  account: smartAccount,
  calls: [
    {
      to: "DESTINATION_ADDRESS",
      value: amount,
      data: "0x",
    },
    {
      to: "DESTINATION_ADDRESS",
      value: amount,
      data: "0x",
    },
  ],
});

// Retrieve user operation receipt
const receipt = await bundlerClient.waitForUserOperationReceipt({
  hash: userOpHash,
});

const transactionHash = receipt.receipt.transactionHash;
```

### Send transaction using ERC-20 Paymaster

To submit the transaction using ERC-20 paymaster, we'll require to first need to approve ERC-20
token to be used by the paymaster. Ideally, we should first check the token allowance, and only
provide approve allowance to be used by the paymaster.

To modify the token allowance, you'll need to perform a write operation on the ERC-20 contract. In
the example below, we're using Pimlico, but be sure to update the paymaster and ERC-20 token
addresses according to your specific case. For using ERC-20 Paymaster, refer to the configuration
for [Pimlico's ERC-20 paymaster in the AccountAbstractionProvider](/#erc-20-paymaster).

```ts
// Use the same accountAbstractionProvider we created earlier.
const bundlerClient = accountAbstractionProvider.bundlerClient!;
const smartAccount = accountAbstractionProvider.smartAccount!;

// Pimlico's ERC-20 Paymaster address
const pimlicoPaymasterAddress = "0x0000000000000039cd5e8aE05257CE51C473ddd1";

// USDC address on Ethereum Sepolia
const usdcAddress = "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238";

const amount = ethers.parseEther("0.00001");

const userOpHash = await bundlerClient.sendUserOperation({
  account: smartAccount,
  calls: [
    // Approve USDC on Sepolia chain for Pimlico's ERC 20 Paymaster
    {
      to: usdcAddress,
      abi: parseAbi(["function approve(address,uint)"]),
      functionName: "approve",
      args: [pimlicoPaymasterAddress, maxUint256],
    },
    {
      to: "DESTINATION_ADDRESS",
      value: amount,
      data: "0x",
    },
    {
      to: "DESTINATION_ADDRESS",
      value: amount,
      data: "0x",
    },
  ],
});

// Retrieve user operation receipt
const receipt = await bundlerClient.waitForUserOperationReceipt({
  hash: userOpHash,
});

const transactionHash = receipt.receipt.transactionHash;
```
